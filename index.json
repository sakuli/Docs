[
{
	"uri": "/docs/change_notes/2.4.0/",
	"title": "V2.4.0",
	"tags": [],
	"description": "",
	"content": "v2.4.0 sakuli v2.4.0 brings new features but also a lot of improvements and bug fixes for enhanced user experience. let\u0026rsquo;s have a look at the major changes for this release.\nsakuli core besides our brand-new preset autodiscovery a lot of improvements went into this release. enhanced scroll behaviour, new config options and improvements for native interactions are just some of them. a detailed list of all applied enhancement and fixes can be found in the changelog.md.\npreset autodiscovery in sakuli 2.4.0 we got rid of tedious manual configuration of presets. instead of listing desired presets in a dedicated \u0026quot;sakuli\u0026quot; section in your package.json file, it is now sufficient to npm install your desired presets. sakuli will automatically detect and enable installed presets for you, no more configuration required!\nscroll behaviour for every interaction with webelements (clicking, highlighting, etc.), sakuli makes sure the respective element is scrolled into the browser\u0026rsquo;s viewport. in 2.4.0 we enhanced this mechanism to stabilize test cases and behave even more like a real user. attention: please note that this new behaviour might lead to a slight increase in test runtime.\nconfigurable screenshot folder structure in sakuli 2.x we changed the default folder structure of error screenshots so they are stored in per-testcase subfolders. 2.4.0 adds a property to re-enable sakuli 1.x storage layout using a single folder.\ntestcase boilerplate new projects bootstrapped via sakuli create project ... now come with a default testcase boilerplate to get you started even faster.\nnative highlight from 2.4.0 on, it is possible to highlight regions detected via image matching like screen.find(\u0026quot;image.png).highlight().\nretrieve active window region in some cases it can be beneficial to limit search input to the current window. sakuli is now able to properly detect the active window region for further image recognition requests, using environment.getregionfromfocusedwinow().\nconfigurable mouse speed native mouse movement used to increase overall execution time of testcases due to it\u0026rsquo;s rather slow default speed. sakuli 2.4.0 makes mouse speed configurable, so it\u0026rsquo;s possible to save some time here!\nenterprise packages forwarder configuration in line with preset autodiscovery we changed the validation mechanism of forwarder properties. property validation now only processes enabled presets to avoid errors with auto discovery.\nprometheus forwarder error state due to a bug previous versions of sakuli\u0026rsquo;s prometheus forwarder did not properly update error states. this messes up reported results and therefor has been fixed in 2.4.0.\nsakuli container git support sakuli containers now support git repositories. it is now possible to automatically clone a repository on container start, which makes sakuli containers even more flexible. simply pass your repo url via environment variable to have you repo\u0026rsquo;s content availble at runtime.\n"
},
{
	"uri": "/docs/configuring_tests/sakuli-properties/",
	"title": "Sakuli properties",
	"tags": [],
	"description": "",
	"content": "sakuli properties project properties    property type: default comment / example     testsuite.id string*: / name of the suite shown in the output and used by the forwarder   testsuite.name string*: ${testsuite.id} descriptive name for the current test suite   testsuite.browser string: firefox browser which is started by the webdriver (it can be overridden by the --browser command line argument)   testsuite.reusebrowser boolean: true configures whether the browser is reused after each testcase (it can be overridden by the --reusebrowser command line argument) (available as tech preview)   testsuite.warningtime number: 0 the warning runtime threshold (seconds) for suite execution. if the warning time is exceeded, the test suite will get the state \u0026lsquo;warning\u0026rsquo;   testsuite.criticaltime number: 0 the critical runtime threshold (seconds) for suite execution. if the critical time is exceeded, the test suite will get the state \u0026lsquo;critical\u0026rsquo;   testsuite.uionly boolean: false configure whether a testsuite should run in ui-only mode or not. if true, no browser will be started. (it can be overridden by the --ui-only command line argument)   sakuli.environment.similarity.default number: 0.99 configures the minimum requires similarity for image based matching. values in range 0 \u0026lt;= x \u0026lt;= 1   sakuli.typedelay number: 300 specifies the amount of time in ms to wait between keypresses   sakuli.encryption.key string: / master key for en- and decryption   sakuli.log.folder string: ${project.rootdir}/_logs folder for log files   sakuli.screenshot.onerror boolean: true enable / disable screenshots on error   sakuli.screenshot.dir string: ${project.rootdir}/_logs/_screenshots folder for screenshot files (if activated)   sakuli.screenshot.storage string: hierarchical configures the way sakuli stores the error screenshots (available from v2.4.0)   sakuli.mouse.action.delay number: 10 delay between mouse actions e.g. mouse button down, mouse button up, scroll, etc. in ms (available from v2.4.0)   sakuli.mouse.movement.speed number: 3000 configures the speed in pixels/second for mouse movement (available from v2.4.0)    sakuli.screenshot.storage available from v2.4.0\nthere are currently two ways of saving error screenshots in _logs:\nflat saves all error screenshots in _screenshots, e.g. _logs |-- sakuli.log |-- _screenshots |-- 2020-01-01t00-00-00_error_testsuiteid_myfirsttestcase.png |-- 2020-01-01t00-00-00_error_testsuiteid_mysecondtestcase.png |-- 2020-01-01t01-01-01_error_testsuiteid_myfirsttestcase.png\nhierarchical saves the error screenshot in the respective testcase directory, e.g. _logs |-- sakuli.log |-- _screenshots |-- testsuiteid_myfirsttestcase | |-- 2020-01-01t00-00-00_error_testsuiteid_myfirsttestcase.png | |-- 2020-01-01t01-01-01_error_testsuiteid_myfirsttestcase.png |-- testsuiteid_mysecondtestcase |-- 2020-01-01t00-00-00_error_testsuiteid_mysecondtestcase.png\nchrome properties    property type: default comment / example     selenium.chrome.arguments string*: / space separated list of chrome arguments, e.g. \u0026ndash;arg1 arg2 \u0026ndash;arg3=value arg4=value   selenium.chrome.headless boolean: false enable / disable headless mode   selenium.chrome.windowsize.width number: / browser window width   selenium.chrome.windowsize.height number: / browser window height   selenium.chrome.excludeswitches string*: / space separated list of chrome command line switches to exclude that chromedriver by default passes when starting chrome. do not prefix switches with \u0026lsquo;\u0026ndash;\u0026rsquo;   selenium.chrome.extensions string*: / comma separated list of extensions to install when launching chrome. each extension should be specified as the path to the packed crx file   selenium.chrome.binarypath string: / sets the path to the chrome binary to use    firefox properties    property type: default comment / example     selenium.firefox.profile string: / sets the profile to use. the profile may be specified as the path to an existing firefox profile to use as a template   selenium.firefox.binary string: / sets the binary to use. the binary may be specified as the path to a firefox executable \\   selenium.firefox.proxy string: / sets the proxy settings for the new session   selenium.firefox.usegeckodriver boolean: false boolean flag whether to use geckodriver or not    edge properties    property type: default comment / example     selenium.edge.proxy string: / sets the proxy settings for the new session   selenium.edge.pageloadstrategy string: \u0026lsquo;normal\u0026rsquo; sets the page load strategy for edge. supported values are \u0026lsquo;normal\u0026rsquo;, \u0026lsquo;eager\u0026rsquo; and \u0026lsquo;none\u0026rsquo;    internetexplorer properties    property type: default comment / example     selenium.ie.introduceflakinessbyignoringprotectedmodesettings boolean: false whether to disable the protected mode settings or not   selenium.ie.ignorezoomsetting boolean: false indicates whether to skip the check that the browser\u0026rsquo;s zoom level is set to 100%   selenium.ie.initialbrowserurl string: / sets the initial url loaded when ie starts. setting this option may cause browser instability   selenium.ie.enablepersistenthover boolean: true flag which configures whether to enable persistent mouse hovering (true by default)   selenium.ie.enableelementcachecleanup boolean: true flag which configures whether the driver should attempt to remove obsolete webelements from its internal cache on page navigation (true by default). disabling this option will cause the driver to run with a larger memory footprint   selenium.ie.requirewindowfocus boolean: false flag which configures whether to require the ie window to have input focus before performing any user interactions (i.e. mouse or keyboard events). this option is disabled by default, but delivers much more accurate interaction events when enabled   selenium.ie.browserattachtimeout number: 0 configures the timeout, in milliseconds, that the driver will attempt to located and attach to a newly opened instance of internet explorer. the default is zero, which indicates waiting indefinitely   selenium.ie.forcecreateprocessapi boolean: false flag which configures whether to launch internet explorer using the createprocess api. if this option is not specified, ie is launched using ielaunchurl, if available. for ie 8 and above, this option requires the tabprocgrowth registry value to be set to 0.   selenium.ie.arguments string*: / space separated list of command-line switches to use when launching internet explorer   selenium.ie.useperprocessproxy boolean: / flag which configures whether proxies should be configured on a per-process basis. if not set, setting a proxy will configure the system proxy. the default behavior is to use the system proxy   selenium.ie.ensurecleansession boolean: false flag which configures whether to clear the cache, cookies, history, and saved form data before starting the browser. using this capability will clear session data for all running instances of internet explorer, including those started manually   selenium.ie.logfile string: / sets the path to the log file the driver should log to   selenium.ie.loglevel string: / sets the iedriverserver\u0026rsquo;s logging level   selenium.ie.host string: / sets the ip address of the driver\u0026rsquo;s host adapter   selenium.ie.extractpath string: / sets the path of the temporary data directory to use   selenium.ie.silent boolean: false sets whether the driver should start in silent mode   selenium.ie.proxy string: / sets the proxy settings for the new session    selenium properties    property type: default comment / example     selenium.proxy string: / configuration parameters for using proxies in webdriver   selenium.httpagent string: / sets the http agent to use for each request   selenium.server string: / sets the url of a remote webdriver server to use. once a remote url has been specified, the builder direct all new clients to that server    "
},
{
	"uri": "/docs/change_notes/2.3.0/",
	"title": "V2.3.0",
	"tags": [],
	"description": "",
	"content": "v2.3.0 sakuli v2.3.0 comes with a lot of improvements in performance and stability as well as with a lot of bug fixes and a completely new forwarder integration. let\u0026rsquo;s have a look at the major changes for this release.\nsakuli core besides node 12 support and adjustments in sakuli click actions, we\u0026rsquo;ve improved cli output in case of check/test failures and added ways to ensure a stable website before performing any action. a detailed list of all applied enhancement and fixes can be found in the changelog.md.\nnode 12 from now on, sakuli also supports the current lts version of node (v12.x, codename lts/erbium), so feel free to upgrade your systems to latest lts. we updated our enterprise containers accordingly, so starting with 2.3.0 they are now running on lts/erbium.\nchanges on _click() functionality a lot of effort went into stabilizing the click functionality on websites. clicking a web element might sound trivial at first, but being as heterogenous as it is, the web allows for quite a few edge cases. depending on the implementation it might be hard for sakuli to reliably perform click actions on buttons, links, etc. until now, we advised to switch to native desktop interactions in such cases to perform clicks without using the webdriver interface. for this release, we spent some time on investigating the root cause for these issues. now sakuli click actions perform several technical validations e.g. whether the element to click is visible, before the actual click is performed. if one of these checks fails, an error will be thrown. on some websites, these strict checks might fail the technical validation. for those cases, it is still possible to avoid all technical checks and validation by passing the configuration object {force: true} to the click action.\n_click(_button(\u0026#34;click me\u0026#34;), {force: true}); // clicks without validation  please note that a forced click might lead to false positives, as no validation takes place.\nfor more information, please have a look at the _click() api documentation.\nimproved cli error messages we improved the error messages of the cli output. you will now receive detailed information about syntax errors in test scripts as well as more detailed information on the root cause for errors.\noptional website stabilization many modern websites use visual effects regularly. such effects have impaired test setups in the past. some users compensated such situations by using _wait() with a fixed timeout. depending on the system the checks are running on, we have observed that a strict _wait() is not reliable. therefore we added _pageisstable() to the sakuli api. _pageisstable() allows you to wait until the dom of your website has stabilized e.g. after animations are finished or dynamic content has been loaded. as soon as the dom is stable, test execution continues. it is possible to configure the maximum timeout to wait and even the intervals in which the dom is checked.\n// wait for the dom to stabilize within a maximum 5 seconds and check in an interval of 100 milliseconds. await _pageisstable(5000, 100);  for more information, please have a look at the _pageisstable() api documentation.\nenterprise packages sakuli prometheus forwarder with 2.3.0, we have added a prometheus forwarder to the enterprise forwarder packages. to use the prometheus forwarder, a valid sakuli enterprise license is required.\nas sakuli checks are not designed to provide a persistent endpoint for prometheus to scrape, the forwarder leverages the prometheus push gateway. for more information about configuration and setup, please have a look at the prometheus forwarder documentation.\ncheckmk forwarder - website link in spool files from now on, sakuli allows to add an optional website url to the checkmk spool files. these urls will be displayed in the checkmk web interface which allows an easy access for the monitoring staff to systems under test in case of an error.\nfor more information, please have a look at the checkmk forwarder documentation.\nsakuli container as usual, we updated the container to use the latest sakuli version, latest security patches and also added node 12 as well as all changes to the enterprise forwarders. besides that, we created a completely new container which aims to control remote windows machines via rdp. the new image can be found in the enterprise repository on docker hub under taconsol/sakuli-remote-connection.\nto be able to use the new taconsol/sakuli-remote-connection image, a valid sakuli enterprise licence of l level or higher is required.\n"
},
{
	"uri": "/docs/enterprise_features/icinga/",
	"title": "Icinga2 Forwarder",
	"tags": [],
	"description": "",
	"content": "icinga2 forwarder add the forwarder using the assistant or configure it manually:\nnpm i @sakuli/forwarder-icinga2 installation of any enterprise feature requires a proper setup of your license information. you can find further information in the enterprise section.\nenable the icinga2 api all steps required to enable the icinga2 api are described in the rest api documentation.\ncreate a icinga2 service create a check_command which will only be executed if icinga2 did not receive a sakuli result within a certain time. this ensures that you get a notification even if no passive check result reaches icinga2 at all:\n/etc/icinga2/conf.d/commands.conf object checkcommand \u0026#34;check_dummy\u0026#34; { import \u0026#34;plugin-check-command\u0026#34; command = [ plugindir + \u0026#34;/check_dummy\u0026#34;,\u0026#34;$dummy_state$\u0026#34;,\u0026#34;$dummy_text$\u0026#34; ] vars.dummy_state = 0 vars.dummy_text = \u0026#34;check was successful.\u0026#34; } object checkcommand \u0026#34;check_sakuli\u0026#34; { import \u0026#34;check_dummy\u0026#34; vars.dummy_state = 3 vars.dummy_text = \u0026#34;no passive sakuli check result received.\u0026#34; }\n/etc/icinga2/conf.d/hosts.conf object host \u0026#34;sakuliclient01\u0026#34; { import \u0026#34;generic-host\u0026#34; address = \u0026#34;\u0026lt;ip\u0026gt;\u0026#34; }\ncreate the following service object for the first testcase. the freshness_threshold should be slightly higher than the interval sakuli tests are planned.\nobject service \u0026#34;sakuli_demo\u0026#34; { import \u0026#34;generic-service\u0026#34; host_name = \u0026#34;sakuliclient01\u0026#34; check_command = \u0026#34;check_sakuli\u0026#34; enable_active_checks = 0 enable_passive_checks = 1 enable_flapping = 0 volatile = 1 enable_perfdata = 1 } reload icinga2:\nservice icinga2 reload after opening icingaweb2 you should see the sakuli host with the service \u0026ldquo;sakuli_demo\u0026rdquo; attached.\nthe check is waiting now for check results from a sakuli client.\nsakuli client configuration you must set the global properties for the icinga2 receiver on the sakuli client by editing the sakuli.properties. you can find them in the folder containing the testsuites:\n   property default effect     sakuli.forwarder.icinga2.enabled false enables result forwarding to icinga2   sakuli.forwarder.icinga2.api.host  the hostname or ip of the icinga2 api-endpoints   sakuli.forwarder.icinga2.api.port 5665 the port or ip of the icinga2 api-endpoints   sakuli.forwarder.icinga2.api.username  api user name   sakuli.forwarder.icinga2.api.password  api user password   sakuli.forwarder.icinga2.hostname  the name of the host object configured in icinga2   sakuli.forwarder.icinga2.service_description ${testsuite.id} the name of the service in icinga2   sakuli.forwarder.icinga2.allow_insecure_connection false disable ssl checks. never use this in production environments!    "
},
{
	"uri": "/docs/getting-started/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "what you need sakuli only supports the active lts release of node. for information on what version this currently covers see the node.js release schedule.\nin order to be able to run sakuli on your system, we will assume that you have a working node installation.\nto install node on your system, you can either go to the node website or you can use tools like node version manager utility to manage various node versions on a per-user basis. in general, a per-user installation is the preferred way since it runs in an unprivileged mode.\n"
},
{
	"uri": "/docs/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "easy start the following video shows a quick introduction on how to install and bootstrap sakuli and how to setup and start your first ui-test on a mac computer. for a detailed installation procedure, please click the green arrow to the right or navigate through the table of content on the left navigation pane.\nyour browser does not support the video tag.   steps to reproduce easy start prerequisite is a node v12 (lts/erbium) installation on your mac.\nnpm init accept all questions with enter key.\nnpm i @sakuli/cli npm i chromedriver npx sakuli create project . my-demo open the file check.jsand insert the following test-script:\n(async () =\u0026gt; { const testcase = new testcase(); try { await _navigateto(\u0026#34;https://sakuli.io\u0026#34;); testcase.endofstep(\u0026#34;open landing page\u0026#34;, 5, 10); await _click(_link(\u0026#34;getting started\u0026#34;)); await _click(_link(\u0026#34;initialization\u0026#34;)); testcase.endofstep(\u0026#34;navigate to initialization section\u0026#34;, 3, 5); await _highlight(_code(\u0026#34;npm init\u0026#34;)); testcase.endofstep(\u0026#34;find npm init code sample\u0026#34;); } catch (e) { await testcase.handleexception(e); } finally { await testcase.saveresult(); } })();  npx sakuli run my-demo "
},
{
	"uri": "/docs/configuring_tests/logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": "logging log levels the default log level in sakuli is info. this means all log levels starting from info and below are logged to sakuli.log. you can configure the log level via log.level in your testsuite.properties file, e.g. log.level=debug\nthere are currently five log levels implemented:\n   log level description     trace highly increased verbosity. provides deep insights into code execution.   debug increased verbosity. logs additional technical details about the test execution.   info information about test execution.   warn something strange happened. the test execution is not critically disturbed and user interaction is not necessarily required in first place.   error the test errored. test execution will be terminated as soon as possible. user interaction is required.    log modes available as tech preview in the @next releases.\n   config description     log.mode=logfile (default) log messages are written into log file   log.mode=ci log messages are written to stdout and log file for downwards compatibility    in case you want to set the log mode via environment variables, please use log_mode with the appropriate value. log modes set via environment variables are overwriting log mode configurations from property files.\nlog mode \u0026lsquo;logfile\u0026rsquo;    sakuli.properties config environment config     log.mode=logfile log.mode=logfile    the default log mode is logfile. with this setting, sakuli puts its log output into a log file under consideration of the given log configuration. the standard console output instead shows an overview of the test execution.\n   console output logfile output          log mode \u0026lsquo;ci\u0026rsquo;    sakuli.properties config environment config     log.mode=ci log.mode=ci    as sakuli is often used within ci/cd environments in the stage of e2e tests, working with log files e.g. inside a container or in a build system is not convenient. therefore, sakuli comes with the option to redirect the log output to the standard output. this mode suppresses the standard overview display of the test execution.\n   console output logfile output          "
},
{
	"uri": "/docs/enterprise_features/prometheus/",
	"title": "Prometheus Fowarder",
	"tags": [],
	"description": "",
	"content": "prometheus forwarder available from version 2.3.0\nadd the forwarder manually as follows:\nnpm i @sakuli/forwarder-prometheus installation of any enterprise feature requires a proper setup of your license information. you can find further information in the enterprise section.\npush gateway it is assumed that a push gateway is available in your monitoring setup. as sakuli checks are not constantly available like e.g. a webservice, it is required to use a prometheus push gateway to provide a scraping endpoint for prometheus to obtain measurements gathered by sakuli.\nforwarder configuration configuration is located in sakuli.properties within the root folder of your project or respectively in testsuite.properties in your testsuite folders for testsuite specific configuration:\n   property default effect     sakuli.forwarder.prometheus.enabled false enables forwarding to prometheus push gateway   sakuli.forwarder.prometheus.api.host  hostname of the prometheus push gateway   sakuli.forwarder.prometheus.api.port 9091 port of the prometheus push gateway service   sakuli.forwarder.prometheus.api.job  name of the job the metrics relate to. e.g. e2e-monitoring-for-my-very-important-application    example configuration sakuli.forwarder.prometheus.enabled=true sakuli.forwarder.prometheus.api.host=prom.push.gateway.mydomain.com sakuli.forwarder.prometheus.api.port=9091 sakuli.forwarder.prometheus.api.job=my-app-e2e-monitoring "
},
{
	"uri": "/docs/enterprise_features/check/",
	"title": "checkmk Fowarder",
	"tags": [],
	"description": "",
	"content": "checkmk forwarder add the forwarder using the assistant or configure it manually:\nadd the forwarder to your project with:\nnpm i @sakuli/forwarder-checkmk installation of any enterprise feature requires a proper setup of your license information. you can find further information in the enterprise section.\nsakuli client configuration it is assumed that the client is already monitored by checkmk and that an agent is installed and running on it.\nspool folder create a new folder spool in the installation path of the checkmk agent. this is the folder where the results will be written and stored into. don\u0026rsquo;t forget to grant writing permissions for the folder to the user running sakuli checks.\nforwarder configuration now you have to set up the properties for the checkmk receiver. in order to do this, edit the sakuli.properties in the folder containing the testsuites:\n   property default effect     sakuli.forwarder.check_mk.enabled false enables writing to the spool file   sakuli.forwarder.check_mk.spooldir /var/lib/check_mk_agent/spool (linux)\u0026lt;cmk_installation_path\u0026gt;\\\\spool (windows) path to the spool folder as defined above. on windows, the backslashes have to be escaped with \u0026lsquo;'. check_mk is expecting the result files from sakuli in here   sakuli.forwarder.check_mk.freshness 600 defines the maximal age in seconds for which the result is still valid. if the last modification of the result file is older than this property, the result file will be ignored. the check_mk service will turn into unknown   sakuli.forwarder.check_mk.spoolfile_prefix sakuli_suite_ defines the result file prefix. it can be used to change the default naming convention for the check_mk output files   sakuli.forwarder.check_mk.service_description ${testsuite.id} defines the service description which is used within the check result   sakuli.forwarder.check_mk.piggyback_hostname local defines hostname for check results, configurable for piggyback results   sakuli.forwarder.check_mk.output.details true dis- / enables detailed html output   sakuli.forwarder.check_mk.section_name local name of the reported section (\u0026lt;\u0026lt;\u0026lt;your_section_name\u0026gt;\u0026gt;\u0026gt;)   sakuli.forwarder.check_mk.url  url address to add to the spool file (available from version 2.3.0)    an example configuration could look like this:\nsakuli.forwarder.check_mk.enabled=true sakuli.forwarder.check_mk.spooldir=/var/lib/check_mk_agent/spool sakuli.forwarder.check_mk.freshness=600 sakuli.forwarder.check_mk.spoolfile_prefix=sakuli_suite_ sakuli.forwarder.check_mk.service_description=my_custom_service sakuli.forwarder.check_mk.piggyback_hostname=myhost "
},
{
	"uri": "/docs/writing_tests/anatomy/",
	"title": "Anatomy",
	"tags": [],
	"description": "",
	"content": "anatomy of a project this guide assumes that you have finished the \u0026ldquo;getting started\u0026rdquo; tutorial or that you are experienced with sakuli v1.\n most of the complexity and conventions are due to the backwards compatibility to v1, which requires a specific folder and file structure for various reasons (the biggest is sahi). sakuli offers now various ways to reduce this complexity dramatically. these features will eventually become part of upcoming releases.\n setup and configuration the minimum setup for a sakuli project looks like this:\n  your-sakuli-project home folder of the project   testsuite-a home folder of a testsuite   _logs an automatically generated folder for error screenshots and sakuli.log   _screenshots folder for error screenshots  sakuli.log logs of sakuli execution    testcase home of the testcase   .check.js.steps.cache an automatically generated cache file  testcase.js the actual testcase    package.json (optional) defines test script for container usage  testsuite.suite defines which testcases belong to the testsuite  testsuite.properties configuration for the testsuite (overrides configuration from \u0026lsquo;../sakuli.properties\u0026rsquo;)    package.json all dependencies and setups for node.js  sakuli.properties (optional) configuration for all testsuites    this file layout also represents the logical structure of sakuli, which consists of a testsuite with one or more testcase(s). sakuli\u0026rsquo;s run command takes the path to a testsuite folder and runs all testcases defined in testsuite.suite of the given folder.\n_logs the folder _logs is created automatically when sakuli starts the first execution of a test suite. to change the path of the created folder _logs you can use sakuli.log.folder. see configuring tests for more information.\n_screenshots sakuli stores all error screenshots in this folder, which can be configured with these properties:\n sakuli.screenshot.onerror sakuli.screenshot.dir sakuli.screenshot.storage  see configuring tests for more information.\nsakuli.log sakuli logs all information about the test execution in this file. to configure the log level, set log.level property in sakuli.properties or testsuite.properties accordingly.\n.steps.cache file the file \u0026lsquo;steps.cache\u0026rsquo; is created after the first successful execution. it contains the step names of a test case (defined with testcase.endofstep()). with the correct .steps.cache file sakuli can omit the last step finished step unnamed with state ok..\ntestsuite.suite this file is a relic from sahi where you define testcases and their respective start-urls. it has a simple format:\n\u0026lt;case-path\u0026gt;/\u0026lt;case-file\u0026gt; \u0026lt;start-url\u0026gt; \u0026lt;case-path\u0026gt; is a path within the testsuite file, which has to contain the file \u0026lt;case_file\u0026gt;. the \u0026lt;start-url\u0026gt; is no longer used by sakuli (but required to fulfil the file format). the format also supports comments (// at the beginning of a line). testcases can be activated or deactivated by using comments.\n the configured start-url is omitted to force test authors to write explicit navigation to the url for testcases using _navigateto.\n properties files each testsuite requires a testsuite.properties file with at least one entry:\ntestsuite.id=somename it \u0026ldquo;inherits\u0026rdquo; its values from ../sakuli.properties (which also means that the same property from sakuli.properties becomes overridden).\n property files are a common way to store configuration in java, the former runtime for sakuli. it is a simple key-value format (\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;) where every line defines a key-value pair. to organize the keys, it is a common - but not required - practice to separate names by dots (similar to java namespaces).\n there are several predefined properties that can be configured to influence the behavior of sakuli (* indicates a required property):\n   property type: default comment / example     testsuite.id string*: / name of the suite shown in the output and used by the forwarder   testsuite.browser string: \u0026lsquo;firefox\u0026rsquo; browser which is started by the webdriver (it can be overridden by the --browser command line argument)    you can also define own properties and use them in your testcases. just put your custom property key with the corresponding value in one of the .property files and into your testcase. you can retrieve the values with help of the environment class:\n// omitting boilerplate // assuming you have added // user.name=tester // in one of the property files const env = new environment(); await _setvalue(_textbox(\u0026#39;username\u0026#39;), env.getproperty(\u0026#39;user.name\u0026#39;));  "
},
{
	"uri": "/docs/getting-started/initialization/",
	"title": "Initialization",
	"tags": [],
	"description": "",
	"content": "initialize a project this guide will get you started with writing sakuli tests from scratch. to follow this tutorial, you should create a new npm project in an empty folder.\nfor this guide, we will assume that our working directory is /tmp/sakuli_starter on a *nix system, or %temp%\\sakuli_starter on a windows machine.\nto create a new, empty project, first run:\nnpm init this interactive prompt will ask you for some metadata regarding your project. you can either modify these fields to your needs or just accept the defaults.\nonce completed, you should see a short summary similar to the following snippet:\nabout to write to /tmp/sakuli_starter/package.json: { \u0026#34;name\u0026#34;: \u0026#34;sakuli_starter\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;isc\u0026#34; } is this ok? (yes) the empty project has been initialized after confirming the prompt.\n"
},
{
	"uri": "/docs/writing_tests/",
	"title": "Writing Tests",
	"tags": [],
	"description": "",
	"content": "writing tests learn how to create fully-fledged sakuli tests from start to finish.\n"
},
{
	"uri": "/docs/configuring_tests/",
	"title": "Configuring Tests",
	"tags": [],
	"description": "",
	"content": "learn how to configure sakuli! "
},
{
	"uri": "/docs/enterprise_features/omd/",
	"title": "OMD Forwarder",
	"tags": [],
	"description": "",
	"content": "omd / gearman forwarder add the forwarder using the assistant or configure it manually:\nnpm i @sakuli/forwarder-gearman installation of any enterprise feature requires a proper setup of your license information. you can find further information in the enterprise section.\nconfigure omd sakuli transmits performance data to a gearman result queue rather than to omd directly. for that we require a gearman-enabled monitoring system in an omd environment.\nit takes a few steps to set up the monitoring system in order to process sakuli\u0026rsquo;s performance data correctly.\nenable and configure mod-gearman use the makefile located in omd_root/share/sakuli/omd/ to configure mod-gearman:\n enable all services for mod-gearman set the bind ip and port (default: 0.0.0.0:4730; overwrite with e.g. export gearman_port=192.168.130.10:4731) set the encryption key (default: sakuli_secret; overwrite with e.g. export gearman_secret=mykey)  then run:\nsu - \u0026lt;site_user\u0026gt; cd ~/share/sakuli/setup/omd make gearman due to security reasons, the makefile will only configure mod-gearman if it is not enabled yet. if it is already enabled inspect the makefile, read the instruction carefully and execute the steps by hand.\nfor production usage please use individual encryption keys!\nif you do not want to use encryption at all, enable accept_clear_results and disable sakuli.forwarder.gearman.encryption:\nvim ~/etc/mod-gearman/server.cfg ... accept_clear_results=yes testsuite.properties sakuli.forwarder.gearman.encryption=false\ngearman proxy (optional) use the sakuli gearman proxy script if you want to intervene between the communication of sakuli and naemon/nagios.\npossible use cases:\n changes parts of the messages sakuli sends to the monitoring system ⇒ there are some examples contained already getting notified when sakuli sends results to services that do not exist auto-create services for incoming results (not yet implemented)  use the makefile located in $omd_root/share/sakuli/ to enable the feature:\nsu - \u0026lt;site_user\u0026gt; cd n/share/sakuli/setup/omd make gearman_proxy edit etc/mod-gearman/sakuli_gearman_proxy.cfg :\n$remotehost=\u0026#34;172.17.0.2\u0026#34;; #1 $remoteport=\u0026#34;4730\u0026#34;; #1 $localhost=\u0026#34;172.17.0.2\u0026#34;; #2 $localport=\u0026#34;4730\u0026#34;; #2 $queues = { \u0026#34;$remotehost:$remoteport/check_results_sakuli\u0026#34; =\u0026gt; \u0026#34;$localhost:$localport/check_results\u0026#34;, }; #3 + 4 $err_h = \u0026#39;error_host\u0026#39;; #5 $err_s = \u0026#39;eror_svc\u0026#39;; $err_r = \u0026#39;2\u0026#39;; #6  gearman ip/port listening for sakuli results. set this to the same values as \u0026lt;2\u0026gt; unless gearman_proxy.pl is running on another system gearman ip/port for the monitoring system check_results_sakuli ⇒ queue name to receive sakuli results. make sure this queue name is defined in property sakuli.forwarder.gearman.server.queue on all sakuli clients (see sakuli client configuration) check_results ⇒ default queue of mod-gearman where gearman workers write back their results (no need to change that) the proxy does a live status query for each incoming package to ensure that the receiving host/service exists. it provides a special \u0026ldquo;error host/service\u0026rdquo; pair where the proxy can send a message in case of results coming back for non-existent services status of the messages for non-existent services (2 = critical)  su - \u0026lt;site_user\u0026gt; omd start sakuli_gearman_proxy # starting sakuli_gearman_proxy...ok check that the queue check_results_sakuli is running in addition to the default queue check_results.\nomd[demo]:~$ gearman_top 2017-06-09 13:37:28 - localhost:4730 - v0.33 queue name | worker available | jobs waiting | jobs running ----------------------------------------------------------------------- check_results | 1 | 0 | 0 check_results_sakuli | 1 | 0 | 0 ----------------------------------------------------------------------- this change does affect other monitoring checks executed with mod-gearman, because only sakuli will send results into the queue check_results_sakuli.\ncreate a nagios service create a service which should receive sakuli test results. host/service names derive from the following properties:\n host: sakuli.forwarder.gearman.nagios.hostname (defined globally or via suite) service: testsuite.id (defined in testsuite.properties)  omd configuration:\ndefine host { host_name sakuli_client alias sakuli_client address __sakuli_client_ip__ use generic-host } define service { service_description example_xfce host_name sakuli_client use tpl_s_sakuli_gearman freshness_threshold 180 }  the freshness_threshold should be slightly higher than the interval during which sakuli tests are executed.\n the check is waiting now for check results from a sakuli client.\nsakuli configuration you must set the global properties for the gearman receiver on the sakuli client. for doing this, edit sakuli.properties in the folder containing the testsuites:\n   property default effect     sakuli.forwarder.gearman.enabled false enable forwarding to omd   sakuli.forwarder.gearman.encryption true enable encryption and set the key only if you did not activate accept_clear_results in mod-gearman. otherwise, set encryption to false   sakuli.forwarder.gearman.secret.key secret-password the password configured in enable and configure mod-gearman   sakuli.forwarder.gearman.server.host  the host where omd is running   sakuli.forwarder.gearman.server.port 4730 the port where gearman is listing (configured in enable and configure mod-gearman)   sakuli.forwarder.gearman.server.queue check_results the default queue for sakuli    "
},
{
	"uri": "/docs/writing_tests/interact/",
	"title": "Interact",
	"tags": [],
	"description": "",
	"content": "interacting with the environment in addition to screenshot-based test actions, sakuli is capable of utilizing your keyboard, clipboard and environment variables. all these features are incorporated with the thenableenvironment interface.\nenvironment variable to get a environment variable you can use getenv(key) or getenvmasked(key). only difference between these two is the log output. getenv(key) will also output key unlike getenvmasked(key). const env = new environment(); const path = await env.getenv(\u0026#34;path\u0026#34;); const homedir = await env.getenvmasked(\u0026#34;home\u0026#34;); `\nproperties you also might want to read some properties of your sakuli.properties/testsuite.properties file. const env = new environment(); const id = await env.getproperty(\u0026#34;testsuite.id\u0026#34;); const browser = await env.getpropertymasked(\u0026#34;testsuite.id\u0026#34;) \nonly difference between these getproperty(key) and getpropertymasked(key) is the log output. getenv(key) will also output key unlike getenvmasked(key).\ngetsimilarity/setsimilarity for screenshot-based testing you can configure image-matching similarity in either testsuite.properties or sakuli.properties file via sakuli.environment.similarity.default. environment.setsimilarity(number) allows to adjust this value during a testcase for additional flexibility.\nconst env = new environment(); await env.setsimilarity(0.83); //resets to the similarity set in sakuli.environment.similarity.default await env.resetsimilarity() const currentsimilarity = await env.getsimilarity();  screenshots you can also take screenshot during a sakuli test, which will be saved on testsuite level. const env = new environment(); //creates a screenshot with the filename \u0026#34;screenshot_during_test.png\u0026#34; await env.takescreenshot(\u0026#34;screenshot_during_test.png\u0026#34;); //creates a screenshot with the filename \u0026#34;2020-02-29t23-59-59_screenshot_during_test.png\u0026#34; await env.takescreenshotwithtimestamp(\u0026#34;screenshot_during_test.png\u0026#34;); \ncommands with the thenableenvironment you can also run terminal commands. if the second parameter is set to true, sakuli throws an exception if the command exits with a code other than 0. runcommand returns a command line result.\nconst env = new environment(); const filelist = await env.runcommand(\u0026#34;ls -al\u0026#34;) // both will never throw an exception even though sudo privileges are needed await env.runcommand(\u0026#34;dpkg -i some_package.deb\u0026#34;); await env.runcommand(\u0026#34;dpkg -i some_package.deb\u0026#34;, false); //this will throw an exception await env.runcommand(\u0026#34;dpkg -i some_package.deb\u0026#34;, true);  os you can use this to identify your operating system const env = new environment(); const os = await env.getosidentifier(); await env.isdarwin(); await env.islinux(); await env.iswindows(); \nkeyboard actions the following snippet shows a possible use-case for native keyboard actions. when initiating a download in firefox, a native file download dialog opens. to start the download, we need to accept the file dialog, something that is not possible within the capabilities of selenium. with sakuli you get the opportunity to work around this problem, just like a real user would do. we can accept the file dialog by simply pressing the enter button. use firefox as a browser for this test to work, as chrome simply downloads the file without user interaction:\n(async () =\u0026gt; { const testcase = new testcase(\u0026#34;test\u0026#34;); const url = \u0026#34;https://nodejs.org/en/\u0026#34;; const env = new environment(); try { await _navigateto(url); await _click(_link(\u0026#34;about\u0026#34;)); await _click(_link(\u0026#34;releases\u0026#34;)); await _click(_link(\u0026#34;dubnium\u0026#34;)); await _highlight(_link(/node-v10.\\d{1,}.\\d{1,}.tar.gz/)); await _click(_link(/node-v10.\\d{1,}.\\d{1,}.tar.gz/)); await _wait(3000); //wait for browser pop-up to activate  await env.keydown(key.enter); await env.keyup(key.enter); } catch (e) { await testcase.handleexception(e); } finally { testcase.saveresult(); } })();  it is even possible to change the download location dynamically in some environments, by entering a new save path via:\nawait env.type(\u0026#34;/new/path/to/file\u0026#34;);  key class sometimes it is necessary to use control keys to navigate through a application. for such a case you can use the key class. a list of all keys can be found in our legacy api docs. const env = new environment(); // open new tab in a browser await env.type(key.t, key.ctrl); // alternatively await env.type(\u0026#34;t\u0026#34;, key.ctrl); // open a terminal in ubuntu using two control keys await env.type(key.t, key.ctrl, key.alt); \ntype/paste vs keydown/keyup as you might have noticed, there are multiple ways to simulate keyboard input with sakuli. on the one hand we have type(text: string, ...optmodifiers: key[]) and paste(text: string) and on the other hand there is keydown(...keys: key[]) with keyup(...keys: key[]). if you just want to input text into a textbox, you might want to use paste because it just pastes the text whereas type \u0026ldquo;simulates\u0026rdquo; the enduser and types every letter individually. with type it is also possible to use modifier keys such as ctrl, cmd or alt. so if you want to use a shortcut like opening a new tab in a browser with ctrl+t, you can handle it with env.type(key.t, key.ctrl). keydown/keyup is useful when you need a key pressed such as ctrl-click a link. this will open the link in a new tab. const env = new environment(); await env.paste(\u0026#34;just paste this text somewhere\u0026#34;); await env.type(\u0026#34;pls write this all in capital letters\u0026#34;, key.shift); //open print dialog await env.type(key.p, key.ctrl); await env.keydown(key.ctrl); //click links to open in a new tab or do something else await env.keyup(key.ctrl); \nclipboard you can also utilize the clipboard to paste a text. const env = new environment(); //just presses ctrl+c await env.copyintoclipboard; const clipboard = await env.getclipboard(); //just presses ctrl+v await env.pasteclipboard() await env.setclipboard(\u0026#34;set this string into the clipboard\u0026#34;); \nmouse wheel const env = new environment(); //scrolls down on a webpage await env.mousewheeldown(10) //scrolls up await env.mousewheelup(5);  sleep similar to _wait in a sakuli webtest, you can use sleep(number) or sleepms(number) to wait on e.g. excel to start. const env = new environment(); //waits 5 seconds await env.sleep(5); //waits 1 second await env.sleepms(1000); \nsecrets many e2e tests require some kind of login. while there is no problem in general, it still requires some mechanism to handle credentials. providing credentials via environment variable is a common practice, but it still is inconvenient when deploying the testcase to another system, since every single environment variable has to be migrated too.\nsakuli comes with a built-in mechanism to deal with sensitive data in testcases. it uses a single masterkey, generated by sakuli itself, to de- or encrypt secrets used in testcases.\nrunning\nnpx sakuli create masterkey  will generate a new masterkey, which should be exported as an environment variable sakuli_encryption_key.\nonce the masterkey has been exported, secrets can be encrypted by running:\nnpx sakuli encrypt \u0026#34;super secret string\u0026#34;  these encrypted secrets can now be stored safely inside your testfile. the thenableenvironment interface provides methods to decrypt these secrets during test execution.\nawait env.typeanddecrypt(\u0026#34;$encrypted_secret\u0026#34;); // alternatively, via clipboard await env.pasteanddecrypt(\u0026#34;$encrypted_secret\u0026#34;); const secret = await env.decryptsecret(\u0026#34;$encrypted_secret\u0026#34;);  "
},
{
	"uri": "/docs/getting-started/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "installation process the following steps are required to set up sakuli to work with multiple browsers. once the initial setup is done, we will dive right into our first test.\nwebdriver installation sakuli utilizes the webdriver protocol to remote control browsers during test execution. in addition to the browser itself, you need to install the corresponding webdriver as well. several wrapper packages can be found on npmjs.com, which allow the installation of the required binaries via npm.\nsince some users encountered issues with geckodriver on firefox, we recommend using chromedriver for now. we are working on fixes and workarounds for geckodriver.\ntherefore, chrome is the preferred browser for running sakuli tests at the moment. a suitable webdriver can be installed via:\nnpm i chromedriver or\nyarn add chromedriver there are also webdriver packages for ie and edge. macos already ships a webdriver for safari, so there is no need to install an additional package.\nattention: be careful to install the correct version of a webdriver package according to the installed browser version. to install e.g. chromedriver for chrome 73 you have to install:\nnpm i chromedriver@73.0.0 sakuli is not limited to work with only a single browser. when installing multiple webdriver packages, you can easily switch between different browsers.\non windows you will have to manually add the respective webdriver location to your systems path variable, otherwise sakuli will not be able to find and use it. therefore, we recommend a global driver installation on windows.\nnpm i -g chromedriver or yarn global add chromedriver\nonce you installed a webdriver package via npm, you will be prompted with its installation path, so you can easily add it to your %path% variable.\nsample path: %userprofile%\\\\appdata\\\\roaming\\\\npm\\\\node_modules\\\\chromedriver\\\\lib\\\\chromedriver\\\\\nsakuli installation 3rd-party dependencies one of sakuli\u0026rsquo;s core components, nut.js, requires opencv. sakuli ships a pre-built version of opencv. nonetheless, the installation still requires some 3rd-party dependencies.\nwindows note: we recommend using powershell during the installation. when using the standard terminal cmd, the installation process might lead to failures due to different behaviour.\nin order to install and run sakuli on windows you need two additional tools: python 2 and the windows build tools.\nto avoid eventual installation problems for windows users we recommend to first install python 2 on your system separately by downloading the required version from the official web page. afterwards you can install the windows build tools manually or via npm using:\nnpm install --global windows-build-tools or\nyarn global add windows-build-tools in case of errors while installing the windows build tools package via npm, please make sure that the powershell is available on your system path. additionally, you should install the windows build tools by using the powershell in administrative mode. see this issue.\nmacos on macos, xcode command line tools are required. you can install them by running: xcode-select --install\nlinux depending on your distribution, linux setups may differ.\nin general, sakuli requires:\n python 2 g++ make libxtst libpng  installation on *buntu: sudo apt-get install build-essential python libxtst-dev libpng++-dev\nthe installation process is an open issue and will be improved in the near future, so using sakuli will become even more enjoyable!\nsakuli installation we will now install sakuli in our newly created project by running:\nnpm i @sakuli/cli or\nyarn add @sakuli/cli this will install sakuli and its required dependencies.\nreference  opencv4nodejs robotjs  "
},
{
	"uri": "/docs/enterprise_features/",
	"title": "Enterprise Features",
	"tags": [],
	"description": "",
	"content": "enterprise features some features of sakuli require an enterprise license. please consult our overview to see and request packages and prices. after you registered for an enterprise subscription, you will get a license-key and an npm access token which are required to use enterprise features.\nassisted setup it is assumed that you have setup your environment as described in the getting started guide.\non the commandline, navigate to the root folder of your sakuli project (where the package.json file is located) and run the following command:\nnpx sakuli enable-enterprise this command starts an assistant which will guide you through the setup of enterprise features. the first question is regarding the sakuli-license key which you should have received after subscribing to an enterprise package.\n? would you like to enter your sakuli license information? (y/n) you can enter n when you have already entered the license information before.\nyou can enter y and paste the license key in the next prompt:\n? please enter your license key: same applies to the npm access token which can be pasted / entered in the next prompt:\n? please enter your npm key: the following prompt asks you about the enterprise features which you want to activate. you can use ↑ and ↓ to navigate the cursor and space to select or deselect a feature. pressing enter will submit your selection and start the setup process.\n? please select enterprise features to bootstrap (press \u0026lt;space\u0026gt; to select, \u0026lt;a\u0026gt; to toggle all, \u0026lt;i\u0026gt; to invert selection) ❯◯ forwarding to icinga2 ◯ forwarding to checkmk ◯ forwarding to omd sakuli will then configure the license information globally and add install and preconfigure the selected enterprise features in your project.\nyou can now just start using your feature:\n forwarding to icinga2 forwarding to checkmk forwarding to omd forwarding to prometheus (currently without cli setup)  the next sections is about how to setup enterprise features manually and in more detail.\nmanual setup with your active sakuli enterprise subscription you will receive an email with:\n sakuli license-key - contains information about your subscription and is used by sakuli itself and a npm-token - allows access to sakuli\u0026rsquo;s private enterprise packages on npm  there are several ways to handle these information. the most simple way for setting up your enterprise features is as follows (substitute the placeholders between the chevrons with the appropriate values):\nglobal configuration the most simple way to get your enterprise features to work is the following configuration (substitute the placeholders marked by the angle-brackets with its appropriate values):\non unix / osx echo \u0026#34;//registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt;\u0026#34; \u0026gt; ~/.npmrc echo \u0026#34;export sakuli_license_key=\u0026lt;put your personal sakuli-license-key here\u0026gt;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc\non windows echo //registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt; \u0026gt; %userprofile%\\.npmrc setx sakuli_license_key=\u0026lt;put your personal sakuli-license-key here\u0026gt;\nthe environment variables might not take effect in the command-line window where the commands above are entered. so you might need to open a new commandline when running the sakuli command.\nthese commands will set the npm-token and license key globally. this is good for a first setup on your machine but might have some shortcomings in more advanced situations. the following paragraphs describe alternative ways to provide npm-token and license information to your sakuli installation.\nnow you are ready to go for using sakuli with its enterprise features like\n checkmk icinga2 omd prometheus  per-project configuration of npm-token you can set the npm-token for each project by adding a .npmrc file to your project\u0026rsquo;s root directory:\non unix / osx # cd path/to/project echo \u0026#34;//registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt;\u0026#34; \u0026gt; .npmrc\non windows # cd path/to/project echo //registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt; \u0026gt; .npmrc\nthis command will create an .npmrc file with the necessary token configuration inside your specific project folder. every upcoming npm install will use this configuration.\nper-project configuration with environment variable if you don\u0026rsquo;t like to save the token in a file (because this file might be shared) you can configure it to use an environment variable:\non unix / osx echo \u0026#34;//registry.npmjs.org/:_authtoken=\\${npm_token}\u0026#34; \u0026gt; ~/.npmrc\non windows echo //registry.npmjs.org/:_authtoken=${npm_token} \u0026gt; %userprofile%\\.npmrc\non unix / osx npm_token=\u0026lt;put your personal npm-token here\u0026gt; npm i \u0026lt;enterprise-package\u0026gt;\non windows set npm_token=\u0026lt;put your personal npm-token here\u0026gt; npm i \u0026lt;enterprise-package\u0026gt;\nthis approach is frequently used in automation scenarios such as ci/cd pipelines and projects that are shared (e.g. via version control systems).\nit is usually not necessary to persist the token since you will seldomly run npm install that often.\nusing the license-key the license-key contains information about your subscription which will be checked by enterprise components before they are executed. in order to provide this license-key to sakuli you also have to set it as an environment variable. because the license-key is read on every single test execution it is useful to store it persistently on your system or set it in a script where the actual test is also called.\nthe name of the environment variable for the license-key is sakuli_license_key.\nmore about environment variables  an environment variable is a dynamic-named value that can affect the way running processes will behave on a computer. they are part of the environment in which a process runs. for example, a running process can query the value of the temp environment variable to discover a suitable location to store temporary files, or the home or userprofile variable to find the directory structure owned by the user running the process.\n - wikipedia, 08/2019\nso basically an environment variable is just a simple key-value pair provided to a certain process e.g. var_name=value. they can be set for each process or system-wide - so that they become accessible for each upcoming process.\nthe approach for integrating an environment variable depends on the respective operating system.\non windows to set up an environment variable on windows you have to:\n open start-menu and type env into the search mask  an entry \u0026lsquo;edit the system environment variables\u0026rsquo; should appear (click on it)   after the system properties dialog showed up  go to the advanced tab click on the button environment variables (at the bottom of the dialog)   you should see two tables including variable and value columns for user variables and system variables  there you can set, edit or delete environment variables permanently on your system (it is recommended to edit the system variables table if possible). a more detailed guide can be found here.\nalternatively you can use rapid environment editor which is a nice tool for editing environment variables on windows.\nin case of a more restrictive environment - where it is not possible to edit environment variables that easily - you can set them in a batch script:\nrun-sakuli.bat set sakuli_license_key=\u0026lt;personal_license\u0026gt; sakuli run .\non linux or osx on linux or osx it is usually a file which sets up the environment for certain processes:\n ~/.bashrc on linux ~/.profile on osx  these files can be changed with every text editor to add, edit or remove environment variables. an environment variable is defined by:\nexport variable_name=value a new variable can be added with the command:\necho \u0026#34;export variable_name=value\u0026#34; \u0026gt;\u0026gt; ~/.bashrc # linux echo \u0026#34;export variable_name=value\u0026#34; \u0026gt;\u0026gt; ~/.profile # osx "
},
{
	"uri": "/docs/enterprise_features/container/",
	"title": "Container",
	"tags": [],
	"description": "",
	"content": "pre-configured container once you obtained a sakuli enterprise license your docker-user will be granted access to the private sakuli test container image. this image is ready to go and ships with already installed:\n sakuli icinga2 / checkmk / omd / prometheus forwarder vnc / novnc chrome / firefox (incl. webdriver)  1 obtaining the image the registered docker-hub user will then be able to pull the private image:\ndocker pull taconsol/sakuli:\u0026lt;image_tag\u0026gt; tech previews of sakuli containers are published as latest. we highly recommend specifying the exact version of sakuli for productive tests/checks.\ncontainers are tagged according to sakuli versions, so in order to use sakuli v2.4.0-1 in a test, one would pull the following image:\ndocker pull taconsol/sakuli:2.1.2 you can find a list of available tags on dockerhub\n2 running sakuli test containers containerized sakuli tests require a valid sakuli license token which has to be provided via the sakuli_license_key environment variable.\ndocker allows to pass environment variables along other parameters when starting a new container:\ndocker run \\  --rm \\  -p 5901:5901 \\  -p 6901:6901 \\  -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; \\  [--shm-size=2g] \\  taconsol/sakuli:2.4.0-1 parameters:\n --rm: the test container will be removed after execution, not just stopped -p: port forwardings. vnc is available on port 5901, the html5 webvnc view is exposed on port 6901 on the docker host -e: environment variable flag which is used to provide the sakuli_license_key to the container \u0026ndash;shm-size: (optional parameter) increases the size of the shared memory space of the container. the default value is 64mb. this might be required when testing larger websites. indicators that a shared memory enlargement is required are container crashes, the erroneous loading of websites or invalid session id errors due to crashed browsers.   sakuli test containers run as non-root user, the default uid is 1000.\n 3 anatomy of a containerized sakuli test in general, the structure of a containerized sakuli test does not differ from any other sakuli test. no changes are required when executing a test inside a container. the only configuration we have to provide, is information about how and which suite should be executed.\n4 configuring a containerized test the default behaviour of a sakuli test container is to run npm test to execute a test suite, so to run a custom test we have to:\n provide the test project to the container specify the location of the test suite inside the container configure what to execute on npm test within the test suite or project  4.1 provide the test project to the container there are various ways to provide test sources to a container:\n bind mounts extending a base image clone a git repository  4.1.1 bind mounts when running a docker container it is possible to mount a file or directory on the docker host into a container. this mechanism can be used to provide a sakuli projects to a sakuli container:\ndocker run \\  -v /path/to/test/project/on/host:/sakuli_project \\  -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; \\  taconsol/sakuli:2.4.0-1 /bin/bash by adding the -v parameter we\u0026rsquo;re mounting the root folder of a sakuli project at /path/to/test/project/on/host on our host machine to /sakuli_project inside the container. we are now able to execute a test suite inside the container via sakuli run /sakuli_project/test_suite_folder.\nbind mounts are easy to use and very useful during development.\nfor further information, please refer to the docker documentation on bind mounts\ninstead of starting the test suite manually via /bin/bash, you could use the default entry point of the container. to be able to do so, you have to specify the environment variable sakuli_test_suite containing the path of the test suite to execute inside the container.\ndocker run \\  -v /path/to/test/project/on/host:/sakuli_project \\  -e sakuli_test_suite=/sakuli_project/test_suite_folder \\  -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; \\  taconsol/sakuli:2.4.0-1 4.1.2 extending a base image once you have a test suite which should be put into work. binding mounts might become cumbersome and makes it hard to reproduce certain state of the test project, suite or case. to ensure a reproducible environment, it would be feasible to build an explicit docker image for test execution.\nwe can do so by creating our own dockerfile next to our project directory:\n  /folder/containing/dockerfile/and/project  dockerfile  testsuite-a  package.json  \u0026hellip;  from taconsol/sakuli:2.4.0-1 add . \\$home/sakuli_project env sakuli_test_suite \\$home/sakuli_project/testsuite-a using this dockerfile, we can now build our own test image by running the following command where the dockerfile is located:\ndocker build -t name-of-my-image . we can now run the newly built image via:\ndocker run -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; name-of-my-image  when working with added files and folders inside a container, one has to ensure correct file permissions for added files.\n 4.1.3 clone a git repository available from v2.4.0\nthe sakuli container provides a mechanism to clone a git repository containing a sakuli project at container start and subsequently executing a testsuite within it: docker run -e git_url=\u0026lt;repository url\u0026gt; -e git_context_dir=\u0026lt;relative path to testsuite\u0026gt; -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; taconsol/sakuli:2.4.0-1\ngit_url specifies the url of the repository to be cloned. to access a private repository, please ensure, your git service provides the possibility to authenticate via url parameters. this is possible with common git services like github, gitlab and bitbucket. to authenticate with a token on github, use: https://\u0026lt;token\u0026gt;@github.com/\u0026lt;username\u0026gt;/\u0026lt;repository.git\u0026gt;.\ngit_context_dir is necessary to specify the path to the sakuli test suite inside the cloned repository.\n4.2 configure command on npm test the main configuration file of a npm project is its package.json file. within this file it\u0026rsquo;s possible to configure npm-scripts, a handy way to execute scripts inside an npm project.\nan empty project initialised via npm init already contains one script: npm test\n... \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, ...  npm test is the default way of executing tests in a npm project, so sakuli tests should be executed this way, too!\nsince sakuli is available in the container, we can run our test by simply calling sakuli run ... on npm test. as your test suites are located within the same folder as our package.json, so a test suite can be run via:\n... \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;sakuli run /path/to/your/test/suite\u0026#34; }, ...  reusing the package.json on project level comes with one limitation: you have only one \u0026ldquo;test\u0026rdquo; script available. if you decide to put multiple test suites into one project, we recommend putting a package.json on suite level as well.\n{ \u0026#34;name\u0026#34;: \u0026#34;test-suite\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;sakuli run .\u0026#34; } }   please notice that this is just suitable if you plan to execute the suite in the container.\n 4.2.1 troubleshooting this topic covers possible errors when running containerized sakuli tests.\n4.2.1.1 additional dependencies in case your test project requires additional dependencies, it\u0026rsquo;s possible to run npm install before executing the sakuli test.\n... \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;npm i \u0026amp;\u0026amp; sakuli run /path/to/your/test/suite\u0026#34; }, ...  on the latest tag (tech preview), the container supports package installation, configurable via the environment variable install_packages=true. this will install all packages defined in your package.json at container startup.\n note: package versions installed inside the container will be overwritten by the version defined in the package.json.\nthis might cause unexpected behavior, if overwriting e.g. sakuli itself (@sakuli/cli) or forwarders.\n 5 viewing / configuring test execution sakuli test containers allow to configure specific details of their runtime environment.\n5.1 vnc access sakuli containers provide access to running containers via vnc on ports 5901 and 6901. by specifying port forwarding (-p) it is possible to configure which ports will be used to connect to a running container on the host system.\ndocker run --rm -p 5901:5901 -p 6901:6901 -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; taconsol/sakuli:2.4.0-1 the example above forwards container ports 5901 and 6901 to the same ports on the host system.\ndocker run --rm -p 5000:5901 -p 6000:6901 -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; taconsol/sakuli:2.4.0-1 in this example container port 5901 is forwarded to port 5000 on the host system, port 6901 is forwarded to port 6000 on the host system. localhost:5000 would be used to connect to the container via vnc client, on localhost:6000 a webvnc view is available in the browser.\n the default password to access a container via vnc is vncpassword. it is highly recommended changing this password in production environments. see section #5.2 for details.\n 5.2 configuring vnc access the following vnc environment variables can be overwritten at the docker run phase to customize your desktop environment inside the container:\nvnc_col_depth, default: 24 // color depth vnc_resolution, default: 1280x1024 // screen resolution vnc_pw, default: vncpassword // vnc password vnc_view_only, default: false // run in view only mode, no keyboard / mouse interaction possible for example, the password for vnc could be set like this:\n~\\$ docker run -p 5901:5901 -p 6901:6901 -e vnc_pw=my-new-password taconsol/sakuli:2.4.0-1 5.3 container user per default all container processes will be executed with user id 1000.\n  using root (user id 0): add the --user flag to your docker run command: ~\\$ docker run -it -p 5901:5901 -p 6901:6901 --user 0 taconsol/sakuli:2.4.0-1 \n  using user and group id of host system add the --user flag to your docker run command: ~$ docker run -it -p 5901:5901 -p 6901:6901 --user $(id -u):\\$(id -g) taconsol/sakuli:2.4.0-1 \n  6 custom certificates internal infrastructure often uses custom certificates with own root cas etc. things like untrusted certificates cause sakuli tests to fail, since no connection to a seemingly insecure host will be established (insecurecertificateerror).\nunfortunately, browsers use their own certificate store, which requires some additional work to add custom certificates.\n6.1 adding custom certificates in order to add custom certificates to a sakuli container, one has to provide two things:\n a directory containing certificates for import (_.crt, _.cer, *.pem) an environment variable called sakuli_trusted_cert_dir which holds the path to the directory where certificates for import are located inside the container  if the environment variable has been set, a startup script will pick up all certificates contained in the given folder and import each of them to all available browser certificate stores within $home, supporting both cert8.db databases for older browser versions as well as cert9.db files for recent browser versions.\n6.2 sample ~$ docker run -v /path/to/certificates/:/certificate_import -e sakuli_trusted_cert_dir=/certificate_import/ taconsol/sakuli:2.4.0-1 6.3 firefox by default, a firefox test uses a new, blank profile for each test suite execution. in order to pick up the added certificates, a firefox profile containing the appropriate certificate database has to be specified via selenium.firefox.profile=/path/to/profile/folder in testsuite.properties. in order to make this process easier, a dedicated firefox profile for use with certificates is located at /headless/firefox-certificates to be used, instead of the generated profiles in /headless/.mozilla/firefox/long_random_id.default.\nattention: if this property is not set, added certificates will have no effect.\n7 remote desktop protocol (rdp) connections there are use cases that cannot be covered with the standard linux based sakuli container e.g. testing software that is only available for microsoft windows or automating processes in sap. if you still want to leverage the flexibility and scalability of a container based sakuli execution, we provide the sakuli-remote-connection container. this image ships with a remmina installation to connect to a remote windows machine using rdp.\n7.1 rdp example to start remmina with a prepared configuration, please ensure to mount the required config file into the container using a volume or to create a base image with the configuration installed.\nsakuli check: (async () =\u0026gt; { const remmina = new application(`remmina --connect \u0026lt;path/to/remmina/config.rdp\u0026gt;`); try { await remmina.open(); await env.sleep(2); //wait for remmina to open  await env.type(key.tab) .type(key.tab) .type(key.enter); //accept certificate  await env.paste(\u0026#34;\u0026lt;username\u0026gt;\u0026#34;) .type(key.tab) .pasteanddecrypt(\u0026#34;\u0026lt;encryptedpassword\u0026gt;\u0026#34;) .type(key.tab) .paste(\u0026#34;\u0026lt;windows ip or hostname\u0026gt;\u0026#34;) .type(key.tab) .type(key.tab) .type(key.enter); //login to windows host  // perform actions on host  await remmina.close(); } catch (e) { await testcase.handleexception(e); } finally { await testcase.saveresult(); } })(); \nsample config.rdp: screen mode id:i:2 session bpp:i:64 compression:i:1 keyboardhook:i:2 displayconnectionbar:i:1 disable wallpaper:i:1 disable full window drag:i:1 allow desktop composition:i:0 allow font smoothing:i:0 disable menu anims:i:1 disable themes:i:0 disable cursor setting:i:0 bitmapcachepersistenable:i:1 full address:s:35.158.200.121 audiomode:i:2 microphone:i:0 redirectprinters:i:0 redirectsmartcard:i:0 redirectcomports:i:0 redirectsmartcards:i:0 redirectclipboard:i:1 redirectposdevices:i:0 autoreconnection enabled:i:1 authentication level:i:0 prompt for credentials:i:1 negotiate security layer:i:1 remoteapplicationmode:i:0 alternate shell:s: shell working directory:s: gatewayhostname:s: gatewayusagemethod:i:4 gatewaycredentialssource:i:4 gatewayprofileusagemethod:i:0 precommand:s: promptcredentialonce:i:1 drivestoredirect:s: \nto execute test actions on the rdp host, we recommend to use keyboard shortcuts instead of image recognition to increase stability. in case you want to use sakuli browser interaction in your check, it is required to install a selenium server on the windows host and configure sakuli to connect the browser functionality with the selenium server.\n8 overview environment variables    environment variable default value description     sakuli_test_suite  path to sakuli testsuite to be executed   sakuli_license_key  sakuli license to use the container   vnc_col_depth 24 color depth of container monitor   vnc_resolution 1280x1024 screen resolution of container   vnc_pw vncpassword password to access novnc/vnc connection   vnc_view_only false enable/disable view-only mode   npm_token  npm token to access npmjs.com registry   sakuli_trusted_cert_dir  directory containing custom certificates for import   git_url  url of git repository   git_context_dir  path to sakuli testsuite within the git repository   debug false enables debug mode for container startup   install_packages false installs packages defined in the package.json at container startup (available on latest tag as tech preview)    "
},
{
	"uri": "/docs/writing_tests/screenshot/",
	"title": "Screenshot",
	"tags": [],
	"description": "",
	"content": "screenshot based testing a lot of e2e scenarios exceed the capabilities of browsers and webdrivers. this might include common use-cases like a drag and drop from the host system to a webpage or exporting a report into a spreadsheet or pdf-format. in these cases, your web-based tests can be extended to also validate behavior and invoke interactions outside the browser, all within a single test.\nof course, you can also use sakulis native testing power on its own, e.g. rich-client testing of sap, office or proprietary software systems. sakuli accomplishes its native capabilities by scanning the whole screen (or a dedicated region) on a stand-alone computer or in headless container screens, searching for provided image patterns.\nscreenshot based actions are relying on an abstract region class, which represents an abstract region on the desktop. when creating a new instance without parameters, a region spans over the whole desktop. but, it is also possible to create new regions by specifying left, top, width and height parameters.\nthe following example represents a test which drags a source element to a target region. in this demo scenario, both source and target are both located on screen via template image. to reproduce this scenario, you need to capture screenshots of the egg and the pan.\n(async () =\u0026gt; { const testcase = new testcase(\u0026#34;native_keyboard_demo\u0026#34;); const url = \u0026#34;https://codepen.io/naturalhanglider/full/jqmwoq\u0026#34;; const screen = new region(); const env = new environment(); try { await _navigateto(url); await env.setsimilarity(0.8); await screen .find(\u0026#34;source_egg.png\u0026#34;) .mousemove() .draganddropto( await screen.find(\u0026#34;target_pan.png\u0026#34;) ); await _wait(3000); } catch (e) { await testcase.handleexception(e); } finally { testcase.saveresult(); } })();   -- your browser does not support the video tag.   the draganddropto(...) methods always move straight to the target region. in order to follow a more complex path, it is also possible to perform the drag gesture manually. once the source image has been located on the screen, sakuli moves the mouse to its location, presses and holds the left mouse button. afterwards, it locates the target image, moves the mouse there while still holding the mouse button and releases it, once it reaches the target location. to reproduce this scenario, you need to capture screenshots of the egg and the pan.\n(async () =\u0026gt; { const testcase = new testcase(\u0026#34;native_demo\u0026#34;); const url = \u0026#34;https://codepen.io/naturalhanglider/full/jqmwoq\u0026#34;; const screen = new region(); const env = new environment(); try { await _navigateto(url); await env.setsimilarity(0.8); await screen .find(\u0026#34;source_egg.png\u0026#34;) .mousemove() .mousedown(mousebutton.left) .setx(0) .sety(0) .mousemove() .move(200, 700) .mousemove(); await screen.find(\u0026#34;target_pan.png\u0026#34;) .mousemove() .mouseup(mousebutton.left); await _wait(3000); } catch (e) { await testcase.handleexception(e); } finally { testcase.saveresult(); } })();  how to control the mouse in a sakuli test sakuli provides two ways to steer mouse movement. either via coordinates, or via screenshot data. in order to search for image data on your screen you have to instantiate a region spanning the entire display to access it\u0026rsquo;s image content.\nmoving the mouse to a screenshot to find a screenshot on the screen, you can use find or waitforimage. with waitforimage you can specify a timeout in which sakuli continuously searches for the screenshot. this is useful, when e.g. starting a program like excel.\nconst screen = new region(); await screen.find(\u0026#34;search_this_screenshot.jpg\u0026#34;) .mousemove(); //searches the screen for 5 seconds for the excel homescreen await screen.waitforimage(\u0026#34;excel_homescreen.jpg\u0026#34;, 5000) .mousemove();  find and waitforimage will return a region for matched screenshots, so chaining as follows might not work, if the second screenshot is not within the region of the first one. const screen = new region(); await screen.find(\u0026#34;google_search.png\u0026#34;) .mousemove() .find(\u0026#34;browser_address_bar.jpg\u0026#34;) .mousemove(); \nto get around this problem, you can use left(range), right(range), above(range) or below(range), which returns a new region. left(range) return a region that is left of the current region\u0026rsquo;s border with a width of range, so it does not include the current region. right, below and above behaves equivalently.\nconst screen = new region(); await new region(500, 500, 100, 100).left(200) //this returns a new region with (300/500/200/100)  you can also manipulate the current region with setx(number), sety(number), seth(number), setw(number) or grow(range). with grow you can expand the current region with range px in all four directions. await screen = new region(); await new region(500, 500, 100, 100).grow(100); //this returns a new region with (400, 400, 300,300) \nmoving the mouse relative to current position one way to change a region's position is to use the move(x, y) method. this allows us to shift a region in x and / or y direction, e.g. const screen = new region(); await screen.find(\u0026#34;login_mask.png\u0026#34;) .mousemove() .click() .type(\u0026#34;myusername\u0026#34;) //shifts the region 50px down to e.g. a password field  .move(0,50) //moves the mouse according to the shifted region  .mousemove() .click() .type(\u0026#34;mypassword\u0026#34;) //shifts the region 50px down and 50px to the right and moves the mouse to e.g. the login button  .move(50,50) .mousemove() .click(); })(); \nmoving the mouse to an absolute position due to the fact that mousemove() always moves the mouse to the center of a region, we need to instantiate a region with a height and width of 1.\nconst screen = new region(); await new region(100, 200, 1, 1).mousemove(); //moves the mouse cursor to (100/200)  drag and drop there are two ways to use drag and drop. firstly, you can use draganddropto(), which drags from one point to another. const screen = new region(); await screen.find(\u0026#34;drag_mouse_start.png\u0026#34;).mousemove().draganddropto(new region(200,200,1,1)); await new region(300,300,1,1).mousemove().draganddropto(new region(1000, 1000, 1, 1)); await new region(0,0,1,1).mousemove().draganddropto(await screen.find(\u0026#34;drag_mouse_end.png\u0026#34;)); \nusing mousedown/mouseup allows us to drag and drop over multiple locations. const screen = new region(); await screen.find(\u0026#34;drag_mouse_start.png\u0026#34;) .mousemove() .mousedown(mousebutton.left) .move(200,200) .mousemove() .move(-100, -100) .mousemove() .mouseup(mousebutton.left); \nmouseup/mousedown can be used with either mousebutton.left, mousebutton.middle or mousebutton.right.\nregion also provides methods to use the keyboards, which also are implemented by environment. this allows for easy chaining, like const screen = new region(); await screen.find(\u0026#34;google_search.png\u0026#34;) .mousemove() .click() .type(\u0026#34;sakuli.io\u0026#34;) //moves to the search button  .move(-100, 100) .mousemove() .click() .sleepms(1000) //moves to the first search result  .move(-400,100) .click(); \n"
},
{
	"uri": "/docs/getting-started/firsttest/",
	"title": "First Setup",
	"tags": [],
	"description": "",
	"content": "setup setup your first test since v2.2.0 sakuli provides an easy to use mechanism to initialize testcases and testsuites.\nnpx sakuli create project . my-sut this will create all necessary files and folders to start writing your first sakuli test right away. with this, you can skip the next section and directly start to write your first test\nsetup the project manually since we wanted to keep sakuli mostly compatible to v1, the file layout looks basically the same for testsuites.\neach testsuite is located in its own particular folder. generally, a testsuite represents the system you want to test. therefore, you need to create that folder in your project root (where the package.json file is located):\nmkdir my-sut to describe the testsuite and its testcases, two additional files are needed: testsuite.properties and testsuite.suite. these files are required for backwards compatibility (they might not be necessary in the future but will at least be supported). these files should be added to the my-sut folder:\ncd my-sut echo \u0026gt; testsuite.suite echo \u0026gt; testsuite.properties we can add the following contents to testsuite.properties:\necho testsuite.id=my-sut \u0026gt; testsuite.properties this is the minimum configuration for using sakuli. the .properties file adds some metadata needed by the sakuli-runtime and can be changed to configure other things like forwarders or the default browser for the execution.\nthe testsuite.suite file tells sakuli which testcases are running. the format is:\n\u0026lt;folder-name\u0026gt;/\u0026lt;file-name\u0026gt;.js \u0026lt;start_url\u0026gt; the actual testcase file must be placed inside a folder (this is due to the format forced by sahi in sakuli v1). the start-url also needs to be added but has no effect in v2+.\nwith this in mind, we can add a testcase file:\nmkdir my-testcase echo \u0026gt; my-testcase/testcase.js and add the following information to the testsuite.suite file:\necho my-testcase/testcase.js https://sakuli.io \u0026gt; testsuite.suite after the setup you can add the actual test code to my-testcase/testcase.js:\n(async () =\u0026gt; { // 1  const testcase = new testcase(); // 2  try { // actual testcode goes here  } catch (e) { await testcase.handleexception(e); // 3  } finally { await testcase.saveresult(); // 4  } })(); // 5  let us examine this piece of code:\n the whole test is wrapped in an async immediate invoked function. it allows us to use the async/await syntax of es6. since sakuli makes heavy use of async operations, it makes your code more readable. to provide sakuli information about our actual testcase, we create a testcase object, which handles the execution of a testcase. if any error occurs during testing, it will be redirected to the testcase object. it triggers sakuli\u0026rsquo;s internal error handling e.g. taking a screenshot of the actual failed test execution. regardless of a failed or passed test execution, sakuli saves all results. this is more like a legacy artifact and will be removed in the future. the () at the end of this line will invoke the defined function. since v2.2.0 sakuli is able to detect this invocation without explicitly chaining the call of done function like in previous versions (it is still possible to add .then(done))  write your first test let us write a simple test using the sakuli.io homepage as test subject. this test will verify if our \u0026ldquo;getting started\u0026rdquo; guide that you are reading at this very moment is still accessible.\n(async () =\u0026gt; { const testcase = new testcase(); try { await _navigateto(\u0026#34;https://sakuli.io/docs\u0026#34;); // 1  testcase.endofstep(\u0026#34;open landing page\u0026#34;, 5, 10); // 2  await _click(_link(/getting started/)); // 3  await _click(_link(/initialization/)); testcase.endofstep(\u0026#34;navigate to initialization section\u0026#34;, 3, 5); await _highlight(_code(\u0026#34;npm init\u0026#34;)); // 4  testcase.endofstep(\u0026#34;find npm init code sample\u0026#34;); } catch (e) { await testcase.handleexception(e); } finally { await testcase.saveresult(); } })();    since we are dealing with a web test, the first thing we want to do is to _navigateto our target page. instead of manually setting up the correct webdriver instance, we just have to provide a target url. sakuli will take care of the rest for us. await indicates that we are patiently waiting for our page to load before we continue with our next testing step.\n  once our initial page load has been completed, it is of our great interest to know how long it took to render. when it comes to runtime, sakuli does not only measure the execution time of testcases,but also allows to split a single testcase into several logical steps. this way it becomes possible to accurately measure the runtime of certain processes like e.g. login, shopping cart, checkout and so on. by calling testcase.endofstep(\u0026quot;open landing page\u0026quot;, 5, 10);, we are ending our first step, the initial page load. additionally, it is also possible to specify warning and critical thresholds for each step. whenever a step exceeds one of these values, the result will change from ok to warning or critical.\n  with sakuli it becomes very easy to interact with web elements. in our current example, we want to _click a _link which is identified by some given text. once again, we do not have to take care of many details, as sakuli will do most of the heavy lifting for us. we are just passing the link text to sakuli, which will search for our desired element using multiple identifiers. due to the implementation of the website (additional whitespaces for both link texts) we are using a regular expression instead of a simple string.this way we do not have to worry about using an id, a css selector or something else to identify our element. as we have already seen in our first test action, await will wait until the test action has been completed.\n  in some cases, it is really helpful to visually verify test execution. sakuli comes with a built-in _highlight function, which will highlight an element with a bright red border. although being useful, _highlight should be used carefully since it will increase the overall testing runtime.\n  execute your first test since sakuli 2 is built with node, there are at least two different ways to execute a sakuli test. we will take a look at each one of them. organizing tests as npm projects makes it easier for you to distribute testcode. everything required to execute the test is described in a project config, so tests should be ready to use after running npm install inside a project. 👍\nnpx because of the way we have set up and configured our project in this guide, sakuli is only available to this particular project. npx is a really handy tool, which allows us to execute our sakuli cli directly from the command line, even though we did not add it to the system path.\nin order to run our first test, we just have to execute npx sakuli run my-sut inside our project folder (e.g. /tmp/sakuli_starter on *nix). by default, sakuli will pick up the browser configured in the testsuite.properties file, but with npx it is possible to change the browser on the fly:\nnpx sakuli run my-sut --browser chrome this command will execute our test in chrome.\nregardless of the browser choice, as long as our site did not slow down, you should see a successful test result, similar to the image on the right. the advantage of running your tests with npx is the flexibility to easily customize your test runs without having to edit files.\n"
},
{
	"uri": "/docs/cookbook/tabs/",
	"title": "Tabs",
	"tags": [],
	"description": "",
	"content": "how can i handle tabs in sakuli? switch focus to another tab the simplest way to switch the tab is based on the position of the tab. this snippet, for example, will switch to the second tab of the browser. let handles = await driver.getallwindowhandles(); await driver.switchto().window(handles[1]); \nto switch back to the first tab, we can use: await driver.switchto().window(handles[0]); \nclosing a tab you can close the currently focused tab with: await driver.close() \nnote: if there is only one tab open and driver.close() is used, the browser will be closed. this would severely affect the functionality of sakuli.\nexample the following snippet shows how to work with tabs. first, a link is clicked which opens a new tab. then a code box is highlighted, the tab is closed again and the focus switches back to the original tab.\n(async () =\u0026gt; { const tc = new testcase(\u0026#34;demonstration on how to handle tabs\u0026#34;); try{ await _navigateto(\u0026#34;https://sakuli.io\u0026#34;); await _click(_link(\u0026#34;docs\u0026#34;)); //switch focus to the opened tab  let handles = await driver.getallwindowhandles(); await driver.switchto().window(handles[1]); //do some stuff on the new tab  await _highlight(_code(\u0026#34;npm init\u0026#34;)) //close the tab and switch back to the first tab  await driver.close() await driver.switchto().window(handles[0]); //the focus is back to sakuli.io  await _highlight(_link(\u0026#34;features\u0026#34;)); } catch (e) { await tc.handleexception(e); } finally { tc.saveresult(); } })();  "
},
{
	"uri": "/docs/cookbook/logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": "logging logging is done via the logger object within a testcase. it provides several methods to log at the respective log level: logger.logdebug(\u0026#34;this will be logged on debug level\u0026#34;); logger.loginfo(\u0026#34;this will be logged on info level\u0026#34;); logger.logwarning(\u0026#34;this will be logged on warning level\u0026#34;); logger.logerror(\u0026#34;this will be logged on error level\u0026#34;); \n"
},
{
	"uri": "/docs/getting-started/version-control/",
	"title": "Version control systems",
	"tags": [],
	"description": "",
	"content": "version control systems we highly recommend using version control systems for your test/check files, configs, etc. this ensures that changes are tracked, eases development processes as well as backup strategies and allows to release versions of tests/checks in relation to a certain version of your system under test. during test/check execution, sakuli creates various files like logs and error screenshots which should be ignored when using version control. common version control systems support strategies to ignore files and folders. here are prepared configurations for you to use with sakuli.\ngit to ignore files and folders in git, a .gitignore file is used. the following snippet contains the config for sakuli.\n#sakuli *.steps.cache **/_logs for more information about .gitingore files, please have a look at the official git documentation.\n"
},
{
	"uri": "/docs/cookbook/handling-forms/",
	"title": "Handling forms",
	"tags": [],
	"description": "",
	"content": "handling forms filling forms and verifying their functionality is one of the major use cases in e2e-testing and -monitoring. most of the web elements have been abstracted from their technical specification in html. an \u0026lt;intput name=\u0026quot;last-name\u0026quot; /\u0026gt;  for example is abstracted as a _textbox(\u0026quot;last-name\u0026quot;) accessor. let\u0026rsquo;s have a look at the most common accessors to interact with forms.\ninput fields textarea filling text into a textarea can easily be achieved by combining the _setvalue() action with the _textarea() accessor.\n\u0026lt;textarea name=\u0026#34;textarea-input\u0026#34; \u0026gt;\u0026lt;/textarea\u0026gt; await _setvalue(_textarea(\u0026#39;textarea-input\u0026#39;), \u0026#39;some longer text maybe...\u0026#39;)  textboxes similar to \u0026lt;textarea\u0026gt; elements, text input fields can easily be filled with text by combining the _setvalue() action with the _textbox() accessor. the _textbox() accessor is configured to catch \u0026lt;input\u0026gt; fields without any type or with type=text.\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;first-name\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;last-name\u0026#34; /\u0026gt; \u0026lt;input id=\u0026#34;street\u0026#34; /\u0026gt; await _setvalue(_textbox(\u0026#39;first-name\u0026#39;) ,\u0026#34;bill\u0026#34;) await _setvalue(_textbox(\u0026#39;last-name\u0026#39;) ,\u0026#34;jobs\u0026#34;) await _setvalue(_textbox(\u0026#39;street\u0026#39;) ,\u0026#34;money blvd.\u0026#34;)  emails similar to \u0026lt;input type=\u0026quot;text\u0026quot;\u0026gt; elements, e-mail input fields can easily be filled with an e-mail address by combining the _setvalue() action with the _emailbox() accessor. the _emailbox() accessor is configured to catch \u0026lt;input\u0026gt; fields or with type=email.\n\u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;mail-input\u0026#34; /\u0026gt; await _setvalue(_emailbox(\u0026#39;mail-input\u0026#39;), \u0026#39;do-not-spam@sakuli.io\u0026#39;)  passwords password fields are a little different compared to standard input fields as they are hiding the provided input. sakuli provides a _password() accessor to access \u0026lt;input\u0026gt; fields with type=password. in combination with the _setvalue() action, it is easily possible to set passwords in those fields.\n\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password-input\u0026#34; /\u0026gt; await _setvalue(_password(\u0026#39;password-input\u0026#39;), \u0026#34;$ecret\u0026#34;)  buttons standard buttons just like other elements, sakuli provides a _button accessor. the difference to e.g. input fields is the action you perform on button elements. instead of setting a text value, you would rather click the button. to do so, sakuli provides a _click action.\n\u0026lt;button\u0026gt;click me\u0026lt;/button\u0026gt; await _click(_button(\u0026#39;click me\u0026#39;));  submit buttons submit buttons are the standard html way of submitting web forms. those buttons provide specialized functionality and markup. therefore sakuli provides a dedicated _submit accessor looking for \u0026lt;input\u0026gt; elements with type=\u0026quot;submit\u0026quot;. such an accessor decorated with a _click action will submit the respective web form associated with the submit button.\n\u0026lt;form\u0026gt; \u0026lt;label\u0026gt;user: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; /\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;password: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; await _click(_submit(\u0026#39;login\u0026#39;));  buttons with images a special kind of buttons is the image submit button that is not displayed as a regular button but represented by an image. these buttons can be accessed by the _imagesubmitbutton accessor which searches for \u0026lt;input\u0026gt; elements with type=\u0026quot;image\u0026quot;. as these elements are still meant to be clicked, a decoration with a _click action is possible.\n\u0026lt;form\u0026gt; \u0026lt;label\u0026gt;user: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; /\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;password: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;image\u0026#34; src=\u0026#34;cool-button.png\u0026#34; name=\u0026#34;login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; await _click(_imagesubmitbutton(\u0026#39;login\u0026#39;));  checkboxes as for many other html elements, sakuli provides a dedicated accessor and action to handle checkbox inputs. by using the _checkbox selector and decorating it with a _check action you are able to check any checkbox on your website.\n\u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;like-pizza\u0026#34;\u0026gt; \u0026lt;span\u0026gt;like pizza?\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; await _check(_checkbox(\u0026#39;like-pizza\u0026#39;));  select boxes selecting a specific value in select boxes is easy using the common accessor/action combination in sakuli. to access the select box, use the _select accessor in combination with the _setselected action. the _select accessor is built to fetch \u0026lt;select\u0026gt; elements from the given dom.\n\u0026lt;select name=\u0026#34;preferred-drink\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;water\u0026#34;\u0026gt;water\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;wine\u0026#34;\u0026gt;wine\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;beer\u0026#34;\u0026gt;beer\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; await _setselected(_select(\u0026#39;preferred-drink\u0026#39;), \u0026#39;beer\u0026#39;);  radiobuttons similar to select boxes, radio buttons come with their own _radio accessor but reuse the _click action. the _radio accessor is looking for \u0026lt;input\u0026gt; fields with type=radio.\n\u0026lt;h2\u0026gt;prefered drink?\u0026lt;/h2\u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;water\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;drink\u0026#34; value=\u0026#34;water\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;wine\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;drink\u0026#34; value=\u0026#34;wine\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;beer\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;drink\u0026#34; value=\u0026#34;beer\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt;  await _click(_radio(1)); // selects \u0026#39;wine\u0026#39;  access by xpath in some cases it might be necessary to use xpath expression to navigate the dom structure because you might use custom html elements or your elements do not match the criteria of sakuli accessors. as the _byxpath accessor is just an accessor as every other, it is possible to combine it with actions.\n\u0026lt;h2\u0026gt;prefered drink?\u0026lt;/h2\u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;water\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;drink\u0026#34; value=\u0026#34;water\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;wine\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;drink\u0026#34; value=\u0026#34;wine\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;beer\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;drink\u0026#34; value=\u0026#34;beer\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt;  await _click(_byxpath(\u0026#34;/html/body/label[2]/span\u0026#34;)); // selects \u0026#39;wine\u0026#39;  "
},
{
	"uri": "/docs/cookbook/waiting/",
	"title": "Waiting",
	"tags": [],
	"description": "",
	"content": "waiting in some cases, it might be required to wait for an animation to finish or for page to load dynamic content to use it in test cases or checks. to achieve this, sakuli provides various options to wait a certain time or for a specified condition until test execution continues.\nstatic wait // wait for three seconds await _wait(3000);  wait for an element to be visible // wait for three seconds until the div \u0026#34;mydiv\u0026#34; is visible await _wait(3000, () =\u0026gt; _isvisible(_div(\u0026#34;mydiv\u0026#34;)));  wait for any condition to be met it is possible to pass a boolean function (function returning true or false) as a second optional parameter of the _wait() action. hence it is not only possible to wait until e.g. an item is visible on the website, but also for any boolean condition required in your use case. the sakuli fetch api is a good point to start but you can also always define your own conditions in your test suite.\n// wait at most three seconds until the first list item contains an entry \u0026#34;sakuli\u0026#34;. await _wait(3000, () =\u0026gt; _areequal(_listitem(0), _listitem(\u0026#34;sakuli\u0026#34;)));  // wait at most three seconds until the textbox is enabled - e.g. after the form has been dynamically loaded. await _wait(3000, () =\u0026gt; _isenabled(_textbox(\u0026#39;enabled-input\u0026#39;)));  // wait at most three seconds until at least 10 products have been loaded. await _wait(3000, () =\u0026gt; _count(\u0026#39;_div\u0026#39;, \u0026#39;product\u0026#39;) \u0026gt;= 10);  wait until page stabilized a very popular use case of the wait() function is to check for a certain element to be visible. mostly this checks tries to verify that a certain asynchronous change has been finished. in some cases it is hard to identify an element to reliably ensure that such an asynchronous task has been finished. therefore the sakuli action api provides a _pageisstable() action.\n// wait at most two seconds until the dom stabilized and check it in 200ms intervals. await _pageisstable();  // wait at most five seconds until the dom stabilized and check it in 200ms intervals. await _pageisstable(5000);  // wait at most five seconds until the dom stabilized and check it in 500ms intervals. await _pageisstable(5000, 500);  abort if page does not stabilize in case the page is not able to stabilize in time, it might be required to abort the test case as e.g. a quality gate for loading the page has not been fulfilled. for such a use case, it is possible to wrap _pageisstable() into assertions of the sakuli assertion api.\n// wait for a stable dom, stop test execution if it does not stabilize within timeout await _assert(_pageisstable());  "
},
{
	"uri": "/docs/cookbook/invalid-session-id/",
	"title": "Error: Invalid session id",
	"tags": [],
	"description": "",
	"content": "oh noes! sakuli crashed with an \u0026ldquo;invalid session id\u0026rdquo; error! when sakuli crashes with an \u0026ldquo;invalid session id\u0026rdquo; error, the webdriver itself crashed or least closed the session the sakuli test or check is using. such a behavior mostly occurs, when the provided resources for the sakuli execution are insufficient. when testing bigger websites, please check if enough shm space is available.\n running sakuli container with \u0026ndash;shm-size increasing shared memory on openshift  "
},
{
	"uri": "/docs/cookbook/container/",
	"title": "Run Container",
	"tags": [],
	"description": "",
	"content": "how to run a container with sakuli tests  sakuli container are only available with an active sakuli subscription.\n the following how-to aims to help unexperienced users getting started with sakuli containers. a sakuli container ships with pre-installed sakuli, monitoring forwarder and other additional features, it is not necessary to install anything on your docker-host, except for docker.\ndownload the image with your logged-in docker-user (which is authorized to access the repository with an active subscription), you first need to download the sakuli image: docker pull taconsol/sakuli:2.2.0\nfolder structure and necessary files you will need a proper sakuli test setup on your docker-host. do one of the following to bootstrap this setup:\neither clone the git repository git clone git@github.com:sakuli/container_bootstrap.git sakuli-container_bootstrap\nor\ndownload the following zip download as zip  after cloning the repo / unzipping the file, you will have a folder structure like this with the proper files to run a test using a sakuli container:  run open a terminal and navigate to the folder \u0026ldquo;sakuli-container_bootstrap*\u0026quot;. within this folder, run the following docker command (you will have to insert your active sakuli license key): docker run --rm -v $(pwd):/suite -p 5901:5901 -p 6901:6901 -e sakuli_test_suite=/suite -e sakuli_license_key=yourlicensekey taconsol/sakuli:2.2.0\nwatch the magic you can use the novnc feature to have a live-view of what is happening within the container by opening the following link on your docker-host while the container is running and a test is executed: http://localhost:6901/?password=vncpassword\nwhat´s more? have a look at our enterprise documentation about container, forwarder etc. to get a more in-depth knowledge on what is happening and on how to customize the execution of sakuli tests.\n"
},
{
	"uri": "/docs/cookbook/proxy/",
	"title": "Container and Proxies",
	"tags": [],
	"description": "",
	"content": "container behind proxies to configure a proxy within your docker container, set one or both of the following environment variables within your docker run command.\n-e http_proxy=http://server-ip:port/ -e https_proxy=http(s)://server-ip:port/  use a http_proxy for http target sites and https_proxy for https sites, if you switch between secure and insecure sites or just to be sure not to worry about it, you can also define both proxies at the same time, e.g. like this:\ndocker run --rm -p 5901:5901 -p 6901:6901 -e http_proxy=http://server-ip:port/ -e https_proxy=http(s)://server-ip:port/ -e sakuli_license_key=yourlicensekey taconsol/sakuli:2.2.0 "
},
{
	"uri": "/docs/cli/",
	"title": "CLI",
	"tags": [],
	"description": "",
	"content": "sakuli cli commands sakuli create project npx sakuli create project [ \u0026lt;path\u0026gt; ] [ \u0026lt;suitename\u0026gt; ] [ --force | -f ] [ --package ] generates a default project structure positionals: path path to create testsuite [optional][default: $pwd] suitename name of testsuite [optional][default: sakuli_test_suite] options: --force (alias -f) forces sakuli to create testsuite --package create additional package.json for testsuite this creates a sakuli testsuite folder with the testsuite.suite and testsuite.properties files and a case1 folder containing an empty check.js. with the --package option, it is possible to create an additional package.json. further information on how to set up a sakuli project and the needed files can be found here.\nsakuli create masterkey npx sakuli create masterkey [ --algorithm ] generates a new masterkey positionals: algorithm the algorithm to create a key for [optional][default: \u0026#34;aes-128-cbc\u0026#34;] this command outputs a masterkey which can be used to encrypt a secret with the sakuli encrypt command or to decrypt a secret in a testcase with a sakuli function like environment.decryptsecret().\nsakuli enable-enterprise npx sakuli enable-enterprise configures and enables enterprise features this command starts an assistant which will guide you through the setup of enterprise features. more information on how to use the enable-enterprise command can be found here.\nsakuli encrypt npx sakuli encrypt \u0026lt;secret\u0026gt; --masterkey encrypts a secret via provided masterkey positionals: secret the secret to encrypt [required] options: --masterkey the masterkey used for encryption [required] to use this command it is necessary to create a masterkey with npx create masterkey first. with npx sakuli encrypt you can now encrypt a secret or password which then can be decrypted in the sakuli testcase with one of the decryption functions like environment.decryptsecret().\nsakuli migrate npx sakuli migrate \u0026lt;path\u0026gt; transforms all legacy testsuites into new syntax positional path path to a legacy suite [required] since sakuli had some minor changes in the syntax with v2, old sakuli v1 testcases need to be adapted to the new syntax. with this command sakuli takes over this task.\nsakuli run npx sakuli run \u0026lt;path\u0026gt; [ options ] runs a sakuli suite positionals: path path to sakuli suite [required] options: browser=\u0026#39;\u0026#39; browser which is started by the webdriver ui-only=\u0026#39;\u0026#39; configures whether the testsuite runs in ui-only mode reusebrowser=\u0026#39;\u0026#39; configures whether the browser is reused after each testcase (available as tech preview) "
},
{
	"uri": "/docs/cookbook/frames/",
	"title": "Frames",
	"tags": [],
	"description": "",
	"content": "how can i handle frames or iframes in sakuli? since v2.2.0 sakuli will automatically detect different frames (and iframes) and will search for elements in each frame when the element can not be found in default frame. but it is also possible to switch between frames manually by using the iframe webelement or its respective index.\nconst myiframe = await _fetch(_iframe(\u0026#39;framename\u0026#39;)); await driver.switchto().frame(myiframe);  const frameindex = 0; await driver.switchto().frame(frameindex);  please note: depending on the size and number of used inline frames, an automated search might limit the performance of the check or test case. in such cases, we recommend a manual frame switch.\n"
},
{
	"uri": "/docs/enterprise_features/s2i/",
	"title": "S2I Image",
	"tags": [],
	"description": "",
	"content": "s2i image sakuli enterprise comes with ready-to-use source to image (s2i) containers for redhat openshift. using this builder container, it is easily possible to create deployable sakuli images shipped with a test suite straight from your code repository.\nsetup to setup the source to image builds on your openshift cluster, it is required to import the images from taconsol/sakuli-s2i. to achieve this, you have to create a docker-registry secret with your \u0026lt;docker-username\u0026gt; and \u0026lt;docker-password\u0026gt; and link it to your builder service account to authenticate on docker.io during build. once you obtained a sakuli enterprise license your docker user will be granted access to the private sakuli s2i images.\noc create secret docker-registry dockerhub-sakuli-secret \\  --docker-server=docker.io \\  --docker-username=\u0026lt;docker-username\u0026gt; \\  --docker-password=\u0026lt;docker-password\u0026gt; \\  --docker-email=unused oc secrets link builder dockerhub-sakuli-secret after you\u0026rsquo;ve created and linked the secret, you can import the images from the secured registry.\noc import-image sakuli-s2i \\  --from=docker.io/taconsol/sakuli-s2i \\  --confirm \\  --scheduled=true \\  --all=true  note: the oc import-image statement is configured to not only import all available sakuli s2i images but also to check for updates automatically.\n adding custom certificates the following requirements have to be met to add custom certificates to a sakuli s2i build:\n an openshift secret holding custom certificates a volume mount for the required certificates an environment variable called sakuli_trusted_cert_dir which holds the path to the directory where certificates for import are located inside the container  certificate secret oc create secret generic custom-certs \\  --from-file=my-first-cert.cer=/path/to/first/cert.cer \\  --from-file=another-cert.crt=/path/to/another/cert.crt \\  --from-file=last-cert.pem=/path/to/last/cert.pem the above snippet will create a new secret called custom-certs which holds three key-value pairs storing our certificates.\ncertificate volume mount the next step to include custom certificates is to mount them in a test container.\nspec: containers: - name: ... image: ... volumemounts: - name: custom-certs mountpath: /etc/custom-certs volumes: - name: custom-certs secret: secretname: custom-certs we are defining a volume custom-certs which holds the content of our previously generated secrets. by mounting this volume in our test container we\u0026rsquo;re able to provide the custom certificates to the container at runtime.\nif one does not want to mount all certificates, certificates can be selected via subpath:\nspec: containers: - name: ... image: ... volumemounts: - name: custom-certs subpath: first-cert.cer mountpath: /etc/custom-certs/first-cert.cer  - name: custom-certs subpath: another-cert.crt mountpath: /etc/custom-certs/another-cert.crt  volumes: - name: custom-certs secret: secretname: custom-certs sakuli_trusted_cert_dir variable the final step to enable custom certificates is to provide the certificate location via environment variable:\nspec: containers: - name: ... image: ... env: - name: sakuli_trusted_cert_dir value: /etc/custom-certs  volumemounts: - name: custom-certs mountpath: /etc/custom-certs volumes: - name: custom-certs secret: secretname: custom-certs firefox by default, a firefox test uses a new, blank profile for each test suite execution. in order to pick up the added certificates, a firefox profile containing the appropriate certificate database has to be specified via selenium.firefox.profile=/path/to/profile/folder in testsuite.properties. in order to make this process easier, a dedicated firefox profile for use with certificates is located at /headless/firefox-certificates to be used, instead of the generated profiles in /headless/.mozilla/firefox/long_random_id.default.\nattention: if this property is not set, added certificates will have no effect.\ncreating an s2i build the following build-config template is ready to use to create sakuli s2i builds for various repositories and test suites. just copy and save the s2i build template as sakuli-s2i-build-template.yml. to process the template some additional information is required that are not part of the template. first of all, you have to provide a sakuli_license_key to be able to execute the images resulting from the build process and you have to specify the repository to pull the test case from as testsuite_repository_url. to install such a basic setup on your openshift cluster, just use the following command and replace the placeholder with actual values.\noc process -f sakuli-s2i-build-template.yml \\  sakuli_license_key=\u0026lt;sakuli_license_key\u0026gt; \\  testsuite_repository_url=\u0026lt;testsuite_repository_url\u0026gt; | oc apply -f - advanced s2i build configuration the provided template comes with a lot of optional parameter to customize your build process. the following table contains all available parameters. additional parameters are specified in the same way as seen in the creating an s2i build section.\n  parameter optional description default value   sakuli_license_key no sakuli2 license key.    testsuite_repository_url no git source url containing the test suite.    testsuite_repository_ref yes git branch/tag reference. master   image yes name for the target image to be build. sakuli-s2i-testsuite   image_tag yes tag to push build images to. latest   testsuite_context_dir yes source folder where the test suite is located.    testsuite_repository_secret yes secret to access the testsuite repository.    builder_image yes name of the builder image. sakuli-s2i   builder_image_tag yes tag of the builder image to use. latest   s2i build template apiversion: v1 kind: template labels: template: sakuli-s2i-testsuite-image-build metadata: annotations: description: build config to create a ready to run sakuli2 container with the specified testsuite tags: consol, sakuli2, custom-image, s2i, source-to-image name: sakuli-s2i-testsuite-image-build parameters: - description: name for the target image of the build. name: image required: true value: sakuli-s2i-testsuite - description: image tag of the target image. name: image_tag required: true value: latest - description: sakuli2 license key. name: sakuli_license_key required: true - description: git source url containing the test suite. name: testsuite_repository_url required: true - description: git branch/tag reference. name: testsuite_repository_ref value: \u0026#34;master\u0026#34; required: true - description: source folder where the test suite is located. name: testsuite_context_dir - description: secret to access the testsuite repository. name: testsuite_repository_secret - description: name of the builder image. name: builder_image required: true value: sakuli-s2i - description: tag of the builder image to use. name: builder_image_tag required: true value: latest objects: - apiversion: v1 kind: imagestream metadata: labels: application: ${image} name: ${image} - apiversion: v1 kind: buildconfig metadata: labels: build: ${image} name: ${image} spec: output: to: kind: imagestreamtag name: ${image}:${image_tag} source: type: git git: ref: ${testsuite_repository_ref} uri: ${testsuite_repository_url} contextdir: ${testsuite_context_dir} sourcesecret: name: ${testsuite_repository_secret} strategy: type: source sourcestrategy: from: kind: imagestreamtag name: ${builder_image}:${builder_image_tag} env: - name: \u0026#34;sakuli_license_key\u0026#34; value: ${sakuli_license_key} triggers: - imagechange: {} type: imagechange - type: configchange increasing shared memory of a sakuli containers on openshift the result of an s2i build is a ready to run sakuli container that can be deployed on openshift as a pod, job or cronjob.\ndepending on the size of the websites to be tested, it might be required to provide more shared memory space to the container. indicators that a shared memory enlargement is required are container crashes, the erroneous loading of websites or invalid session id errors due to crashed browsers. in order to do so, two steps are required.\n creating a volume to be used as shared memory mounting the shared memory volume into the container  the following snippet shows the required configuration for a pod deployment:\napiversion: v1 id: sakuli-test kind: pod metadata: name: sakuli-test labels: name: sakuli-test spec: volumes: - name: dshm emptydir: medium: memory containers: - image: mysakulitest:latest name: mysakulitest ... volumemounts: - mountpath: /dev/shm name: dshm more information concerning shared memory on openshift can be found in the okd documentation.\ncreating s2i builds with remote desktop protocol (rdp) support in case rdp support is required, please use sakuli-s2i-remote-connection as builder image. more information about rdp support in containers can be found in remote-connection-container.\ntroubleshooting pulling image error : \u0026hellip; affected openshift versions: 3.10, 3.11\nso far, this error occurred on 3.10 and 3.11 clusters when trying to pull our s2i image from our private dockerhub repo. a workaround to solve this issue was to use reference-policy=local on the sakuli-s2i image stream.\noc import-image sakuli-s2i \\  --from=docker.io/taconsol/sakuli-s2i \\  --confirm \\  --scheduled=true \\  --all \\  --reference-policy=local limitation concerning sakuli.properties instead of defining a sakuli test suite in testsuite_context_dir, you can specify your sakuli project. this will create an s2i container containing the \u0026lsquo;sakuli.properties\u0026rsquo; file included in the cloned project. since a sakuli project is used as the context, a package.json on the project level is required with a test script that starts the desired test-suite, e.g. sakuli run my-test-suite.\n"
},
{
	"uri": "/docs/writing_tests/application/",
	"title": "Native applications",
	"tags": [],
	"description": "",
	"content": "interacting with a native application now that we have covered how to interact with an operating system and used screenshot based testing capabilities of sakuli, we can move on how to utilize one or multiple applications. all features are incorporated in the thenableapplication interface.\nopen an application to open an application, you enter the path to the application or respectively the application name, if you already added it to your path environment variable. if your path contains spaces, you have to escape them with \\\\ because white spaces are reserved for parameter separation. // path to excel \u0026#39;c:\\\\path to excel \\excel.exe\u0026#39; const excel = new application(\u0026#34;c:\\\\path\\\\ to\\\\ excel\\excel.exe\u0026#34;); await excel.open(); // open browser with parameters const chromium = new application(\u0026#34;chromium-browser --incognito --proxy-server=localhost:1234\u0026#34;); await chromium.open(); // path to chrome is e.g. \u0026#39;c:\\\\program\\\\ files\\google-chrome\\chrome.exe\u0026#39; const chrome = new application(\u0026#34;c:\\\\program\\\\ files\\google-chrome\\chrome.exe --incognito\u0026#34;); await chrome.open(); \nafter creating an application with new application(), it is necessary to call open() for sakuli to start it.\nwith setsleeptime(seconds) you can set the waiting time after opening an application. this is particularly useful for larger applications that have an initial loading time. const calc = new application(\u0026#34;gnome-calculator\u0026#34;); //sleeptime of 1 second await calc.setsleeptime(1) .open(); \nclosing an application you can either use close() or kill(). close() sends a sigterm signal and kill() a sigkill signal to end the process.\nawait calc = new application(\u0026#39;gnome-calculator\u0026#39;).open(); await calc.close(); await calc.kill(); //throws an exception if ending the process fails await calc.close(false); await calc.kill(false);  combining with region currently (sakuli v2.3.0) it is not possible to get the region from the application or the focused window. therefore the following methods will return the desktop instead.\nconst calc = new application(\u0026#39;gnome-calculator\u0026#39;); await calc.open() .getregion(); await calc.open() .getregionforwindow();  "
},
{
	"uri": "/docs/cookbook/",
	"title": "Cookbook",
	"tags": [],
	"description": "",
	"content": "browse through our cookbook and get answers, best practices and tipps\u0026amp;tricks right away\u0026hellip;! "
},
{
	"uri": "/docs/enterprise_features/sakuli-dashboard-deployment/",
	"title": "Sakuli Dashboard",
	"tags": [],
	"description": "",
	"content": "sakuli dashboard the sakuli dashboard streamlines your e2e application monitoring with sakuli. it helps you start your sakuli test automatically with a cronjob to monitor your application continuously or trigger it manually with a button. while watching a live video feed of your sakuli check, you can track the monitoring metrics of your application by embedding your monitoring graphs into the sakuli dashboard.\nhow to get the sakuli dashboard attention: only sakuli enterprise users will be eligible to access the private sakuli dashboard docker images. sakuli dashboard releases are versioned following the semantic versioning scheme. images for stable releases are tagged accordingly. tech-previews of upcoming stable releases are available via the latest tag.\nit is highly discouraged to run tech-previews in production as there is no guarantee of stability.\n deploy the sakuli dashboard with docker deploy the sakuli dashboard with docker-compose deploy the sakuli dashboard with kubernetes deploy the sakuli dashboard with openshift   you will come across configurations such as the dashboard_config, the action_config, the cluster_config and the cronjob_config which configure your sakuli dashboard. for further information about how to properly configure the dashboard check out the sakuli dashboard configuration documentation.\n sakuli dashboard with docker 1 obtaining the image sakuli dashboard images are available to your licensed docker user via docker hub. you need to login to your account before pulling the image. docker login -u \u0026lt;docker-username\u0026gt; docker pull taconsol/sakuli-dashboard:\u0026lt;image_tag\u0026gt;\n2 running the sakuli dashboard docker run --rm \\  -p 8080:8080 \\  -e dashboard_config=\u0026#34;${dashboard_config}\u0026#34; \\  -e action_config=\u0026#34;${action_config}\u0026#34; \\  -e cluster_config=\u0026#34;${cluster_config}\u0026#34; \\  -e cronjob_config=\u0026#34;${cronjob_config}\u0026#34; \\  -e sakuli_license_key=\u0026#34;${sakuli_license_key}\u0026#34; \\  taconsol/sakuli-dashboard:\u0026lt;image_tag\u0026gt; parameters:\n --rm: the dashboard container will be removed after execution, not just stopped -p: port forwarding to access the dashboard container on port 8080 -e: environment variable flags which are used to provide the sakuli_license_key and configure the dashboard  sakuli dashboard with docker-compose the following template allows you to run a dashboard using docker-compose:\nversion: \u0026#34;3\u0026#34; services: sakuli: container_name: sakuli-dashboard image: taconsol/sakuli-dashboard:\u0026lt;image_tag\u0026gt; ports: - 8080:8080 environment: - dashboard_config=${dashboard_config} - action_config=${action_config} - cluster_config=${cluster_config} - cronjob_config=${cronjob_config} - sakuli_license_key=${sakuli_license_key} after creating the \u0026lt;filename\u0026gt;.yml configuration file, you can start the dashboard with: docker-compose up -f /path/to/file/\u0026lt;filename\u0026gt;.yml\nsakuli dashboard on kubernetes prerequisites a sakuli dashboard setup on your kubernetes cluster requires you to import the sakuli dashboard image from docker hub. in order to do so, please configure a secret storing your \u0026lt;docker-username\u0026gt; and \u0026lt;docker-password\u0026gt; and add it to your service account for authentication.\nkubectl create secret docker-registry dockerhub-sakuli-secret \\  --docker-server=docker.io \\  --docker-username=\u0026lt;docker-username\u0026gt; \\  --docker-password=\u0026lt;docker-password\u0026gt; \\  --docker-email=unused kubectl patch serviceaccount default -p \u0026#39;{\u0026#34;imagepullsecrets\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;dockerhub-sakuli-secret\u0026#34;}]}\u0026#39; you can start your sakuli dashboard using two different approaches:\n set up the sakuli dashboard manually via cli. set up the sakuli dashboard using a ready to use template.  set up the sakuli dashboard manually as a first step, create a deployment based on the sakuli dashboard image and expose the service.\nkubectl create deployment sakuli-dashbaord --image=taconsol/sakuli-dashboard:\u0026lt;image_tag\u0026gt; kubectl expose deployment sakuli-dashboard --type=loadbalancer --port=8080 the --type=loadbalancer flag is important to make your service available outside your cluster.\nnow add your sakuli dashboard configurations such as the dashboard, action, cluster and cronjob configs and your sakuli license key to the environment of your deployment.\nkubectl set env deployment/sakuli-dashboard --overwrite \\  dashboard_config=\u0026#34;${dashboard_config}\u0026#34; \\  action_config=\u0026#34;${action_config}\u0026#34; \\  cluster_config=\u0026#34;${cluster_config}\u0026#34; \\  cronjob_config=\u0026#34;${cronjob_config}\u0026#34; \\  sakuli_license_key=\u0026#34;${sakuli_license_key}\u0026#34; set up sakuli dashboard using a template the sakuli dashboard kubernetes template references the sakuli license key via a secret. so before applying the template, please add your license key secret first.\nkubectl create secret generic sakuli-license-key \\  --from-literal=\u0026#34;sakuli_license_key=${sakuli_license_key}\u0026#34; the following ready-to-use template will configure a sakuli dashboard and deploy it to your cluster just copy and save the dashboard template below as dashboard-template.yml. furthermore, add your dashboard, action, cluster and cronjob configurations listed under configmap as well as the image tag.\napiversion: apps/v1 kind: deployment metadata: name: sakuli-dashboard labels: app: sakuli-dashboard spec: replicas: 1 selector: matchlabels: app: sakuli-dashboard template: metadata: labels: app: sakuli-dashboard spec: containers: - name: sakuli-dashboard # specify the sakuli dashboard version you want to use image: taconsol/sakuli-dashboard:${image_tag} imagepullpolicy: always env: - name: action_config valuefrom: configmapkeyref: name: sakuli-dashboard key: action_config - name: cluster_config valuefrom: configmapkeyref: name: sakuli-dashboard key: cluster_config - name: dashboard_config valuefrom: configmapkeyref: name: sakuli-dashboard key: dashboard_config - name: cronjob_config valuefrom: configmapkeyref: name: sakuli-dashboard key: cronjob_config - name: sakuli_license_key valuefrom: secretkeyref: name: sakuli-license-key key: sakuli_license_key --- apiversion: v1 kind: service metadata: name: sakuli-dashboard spec: selector: app: sakuli-dashboard ports: - protocol: tcp port: 8080 targetport: 8080 type: loadbalancer --- apiversion: v1 kind: configmap metadata: name: sakuli-dashboard data: dashboard_config: \u0026gt;- dashboard configuration action_config: \u0026gt;- action configuration cluster_config: \u0026gt;- cluster configuration cronjob_config: \u0026gt;- cronjob configuration to create the deployment in your kubernetes cluster, just use the following command.\nkubectl apply -f dashboard-template.yml sakuli dashboard on openshift prerequisites a sakuli dashboard setup on your openshift cluster requires you to import the sakuli dashboard image from docker hub. in order to do so, please configure a secret storing your \u0026lt;docker-username\u0026gt; and \u0026lt;docker-password\u0026gt; and add it to your service account for authentication.\noc create secret docker-registry dockerhub-sakuli-secret \\  --docker-server=docker.io \\  --docker-username=\u0026lt;docker-username\u0026gt; \\  --docker-password=\u0026lt;docker-password\u0026gt; \\  --docker-email=unused enable access to the secret from the default service account:\noc secrets link default dockerhub-sakuli-secret --for=pull now you can import the image:\noc import-image sakuli-dashboard \\  --from=docker.io/taconsol/sakuli-dashboard \\  --confirm \\  --scheduled=true \\  --all=true when using openshift v3.10 or v3.11, add the --reference-policy=local flag:\noc import-image sakuli-dashboard \\  --from=docker.io/taconsol/sakuli-dashboard \\  --confirm \\  --scheduled=true \\  --all \\  --reference-policy=local note: the oc import-image statement is configured to not only import all available sakuli-dashboard images but also to check for updates automatically.\nyou can start your sakuli dashboard using two different approaches:\n set up the sakuli dashboard manually via cli. set up the sakuli dashboard using a ready to use template.  set up the sakuli dashboard manually via cli an easy way to set up a sakuli dashboard is by using oc new-app. required environment variables can be passed along via the -e parameter.\noc new-app sakuli-dashboard \\  -e dashboard_config=\u0026#34;${dashboard_config}\u0026#34; \\  -e action_config=\u0026#34;${action_config}\u0026#34; \\  -e cluster_config=\u0026#34;${cluster_config}\u0026#34; \\  -e cronjob_config=\u0026#34;${cronjob_config}\u0026#34; \\  -e sakuli_license_key=\u0026#34;${sakuli_license_key}\u0026#34; once completed, the service has to be exposed to make available from outside the cluster.\noc expose svc/sakuli-dashboard set up the sakuli dashboard using a ready to use template the sakuli dashboard openshift template references the sakuli license key via a secret. so before applying the template, please add your license key secret first.\noc create secret generic sakuli-license-key \\  --from-literal=\u0026#34;sakuli_license_key=${sakuli_license_key}\u0026#34; the following ready-to-use template will configure a sakuli dashboard and deploy it to your cluster just copy and save the dashboard template below as dashboard-template.yml. furthermore, add your dashboard, action, cluster and cronjob configurations listed under configmap as well as the containers image configuration.\napiversion: v1 kind: template metadata: name: ${service_name} objects: - apiversion: v1 kind: deploymentconfig metadata: name: ${service_name} labels: app: ${service_name} spec: replicas: 1 selector: app: ${service_name} template: metadata: labels: app: ${service_name} spec: containers: - name: ${service_name} #change the address to your openshift registry, your namespace and the image tag you want to use image: ${openshift_registry_address}/${namespace}/sakuli-dashboard:${image_tag} imagepullpolicy: always ports: - containerport: 8080 protocol: tcp env: - name: action_config valuefrom: configmapkeyref: name: ${service_name} key: action_config - name: dashboard_config valuefrom: configmapkeyref: name: ${service_name} key: dashboard_config - name: cluster_config valuefrom: configmapkeyref: name: ${service_name} key: cluster_config - name: cronjob_config valuefrom: configmapkeyref: name: ${service_name} key: cronjob_config - name: sakuli_license_key valuefrom: secretkeyref: name: sakuli-license-key key: sakuli_license_key triggers: - type: configchange - apiversion: v1 kind: service metadata: name: ${service_name} labels: app: ${service_name} spec: ports: - name: 8080-tcp port: 8080 protocol: tcp targetport: 8080 selector: app: ${service_name} - apiversion: v1 kind: configmap metadata: name: ${service_name} data: action_config: \u0026gt;- \u0026lt;action configuration\u0026gt; cluster_config: \u0026gt;- \u0026lt;cluster configuration\u0026gt; dashboard_config: \u0026gt;- \u0026lt;dashboard configuration\u0026gt; cronjob_config: \u0026gt;- \u0026lt;cronjob configuration\u0026gt; parameters: - name: service_name description: service name for dashboard value: sakuli-dashboard after configuring the template, run:\noc process -f \u0026lt;filename\u0026gt; | oc create -f - whereas \u0026lt;filename\u0026gt; is the name of a file containing the template above.\nexpose the service to make the dashboard available to clients outside of your cluster:\noc expose svc/sakuli-dashboard "
},
{
	"uri": "/docs/writing_tests/webtests/",
	"title": "Webtests",
	"tags": [],
	"description": "",
	"content": "web tests for dom based testing most of the functions from sahi tests can be used (please note that sakuli only implements the open source apis).\nthe main difference between sakuli v1 and sakuli v2 is the usage of promises in the action api, meaning that you have to await a click for example.\non the other hand, element selectors remain synchronized functions but will not do the actual dom fetching anymore. while an expression like var $e=_link('sakuli') did an actual dom-access in sakuli v1.x, it returns a kind of abstract query for an element now. so, action can fetch this element whenever it is required.\na detailed list of all available functions can be found in the sahi api interface,\naccessor api the accessor api is described in the accessor api interface.\nsakuli uses the concept of reusable queries rather than directly working on an element-object (like in selenium). sakuli offers an expressive set of accessors like _div, _textbox or _table. these accessors will not return an actual element or any reference to it. rather it will create a sahielementquery. this query can then be used in various actions like _click, _highlight or _isvisible. this concept could be compared with locators in selenium.\nthis architecture gives us two nice benefits:\n compatibility with sahi api since sakuli handles the actual fetching and validation of an element by performing retries, refreshes, implicit wait etc. which reduce annoying issues with selenium a lot (e.g. staleelementreferenceerror)  most accessors are defined in the same way: they are functions that take an accessoridentifier as a first parameter and a variadic list of relations:\n_name(identifier, ...relations): sahielementquery  the accessor adds a static locator to the returned query. since\na query object consists of a locator, an identifier and a list of relations, we will eventually get an entire query object. the locator basically is a css element selector which you would expect from the accessor name - so _div for example adds by.css('div'), _textbox adds by.css('input[type=\u0026quot;text\u0026quot;], input:not([type])') and so on.\naccessors by html-tag or attributes    html-tag accessor function     \u0026lt;a\u0026gt; _link   \u0026lt;area\u0026gt; _area   \u0026lt;article\u0026gt; _article   \u0026lt;aside\u0026gt; _aside   \u0026lt;blockquote\u0026gt; _blockquote   \u0026lt;b\u0026gt; _bold   \u0026lt;button\u0026gt; _button   \u0026lt;button type=\u0026quot;reset\u0026quot;\u0026gt; _reset   \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt; _submit   \u0026lt;canvas\u0026gt; _canvas   \u0026lt;code\u0026gt; _code   \u0026lt;dd\u0026gt; _ddesc   \u0026lt;details\u0026gt; _details   \u0026lt;div\u0026gt; _div   \u0026lt;dl\u0026gt; _dlist   \u0026lt;dt\u0026gt; _dterm   \u0026lt;em\u0026gt; _emphasis   \u0026lt;embed\u0026gt; _embed   \u0026lt;fieldset\u0026gt; _fieldset   \u0026lt;figcaption\u0026gt; _figcaption   \u0026lt;figure\u0026gt; _figure   \u0026lt;font\u0026gt; _font   \u0026lt;footer\u0026gt; _footer   \u0026lt;frame\u0026gt; _frame   \u0026lt;header\u0026gt; _header   \u0026lt;hr\u0026gt; _hr   \u0026lt;h1\u0026gt; _heading1   \u0026lt;h2\u0026gt; _heading2   \u0026lt;h3\u0026gt; _heading3   \u0026lt;h4\u0026gt; _heading4   \u0026lt;h5\u0026gt; _heading5   \u0026lt;h6\u0026gt; _heading6   \u0026lt;i\u0026gt; _italic   \u0026lt;iframe\u0026gt; _iframe   \u0026lt;iframe\u0026gt; _rte   \u0026lt;img\u0026gt; _image   \u0026lt;input type=\u0026quot;checkbox\u0026quot;/\u0026gt; _checkbox   \u0026lt;input type=\u0026quot;date\u0026quot;/\u0026gt; _datebox   \u0026lt;input type=\u0026quot;datetime\u0026quot;/\u0026gt; _datetimebox   \u0026lt;input type=\u0026quot;datetime-local\u0026quot;/\u0026gt; _datetimelocalbox   \u0026lt;input type=\u0026quot;email\u0026quot;/\u0026gt; _emailbox   \u0026lt;input type=\u0026quot;file\u0026quot;/\u0026gt; _file   \u0026lt;input type=\u0026quot;hidden\u0026quot;/\u0026gt; _hidden   \u0026lt;input type=\u0026quot;image\u0026quot;/\u0026gt; _imagesubmitbutton   \u0026lt;input type=\u0026quot;month\u0026quot;/\u0026gt; _monthbox   \u0026lt;input type=\u0026quot;number\u0026quot;/\u0026gt; _numberbox   \u0026lt;input type=\u0026quot;password\u0026quot;/\u0026gt; _password   \u0026lt;input type=\u0026quot;radio\u0026quot;/\u0026gt; _radio   \u0026lt;input typerange\u0026quot;/\u0026gt; _rangebox   \u0026lt;input type=\u0026quot;search\u0026quot;/\u0026gt; _searchbox   \u0026lt;input type=\u0026quot;tel\u0026quot;/\u0026gt; _telephonebox   \u0026lt;input type=\u0026quot;text\u0026quot;/\u0026gt; _textbox   \u0026lt;input type=\u0026quot;time\u0026quot;/\u0026gt; _timebox   \u0026lt;input type=\u0026quot;url\u0026quot;/\u0026gt; _urlbox   \u0026lt;input type=\u0026quot;week\u0026quot;/\u0026gt; _weekbox   \u0026lt;label\u0026gt; _label   \u0026lt;main\u0026gt; _main   \u0026lt;map\u0026gt; _map   \u0026lt;mark\u0026gt; _mark   \u0026lt;nav\u0026gt; _nav   \u0026lt;object\u0026gt; _object   \u0026lt;p\u0026gt; _paragraph   \u0026lt;pre\u0026gt; _performatted   \u0026lt;section\u0026gt; _section   \u0026lt;select\u0026gt; _option   \u0026lt;select\u0026gt; _select   \u0026lt;span\u0026gt; _span   \u0026lt;strong\u0026gt; _strong   \u0026lt;summary\u0026gt; _summary   \u0026lt;ellipse/\u0026gt; _svg_ellipse   \u0026lt;circle/\u0026gt; _svg_circle   \u0026lt;line/\u0026gt; _svg_line   \u0026lt;path/\u0026gt; _svg_path   \u0026lt;polygon/\u0026gt; _svg_polygon   \u0026lt;polyline/\u0026gt; _svg_polyline   \u0026lt;rect/\u0026gt; _svg_rect   \u0026lt;text\u0026gt; _svg_text   \u0026lt;tspan\u0026gt; _svg_tspan   \u0026lt;table\u0026gt; _table   \u0026lt;td\u0026gt; _cell   \u0026lt;textarea type=\u0026quot;text\u0026quot;/\u0026gt; _textarea   \u0026lt;time\u0026gt; _time   \u0026lt;th\u0026gt; _tableheader   \u0026lt;tr\u0026gt; _row   \u0026lt;ul\u0026gt; _list   \u0026lt;li\u0026gt; _listitem   \u0026lt;video\u0026gt; _video       html-attribute accessor function     \u0026lt;[html - tag] class='[class name]'\u0026gt;\u0026lt;/[html - tag]\u0026gt; _byclassname   \u0026lt;[html - tag] id='[id name]'\u0026gt;\u0026lt;/[html - tag]\u0026gt; _byid    elementqueries since sakuli encapsulates the creation (through accessors) and the application (e.g. through actions) of a sahielementquery, a user will rarely get in touch with these objects directly. nevertheless, it is good to understand how sakuli works with queries. let us consider this example:\nawait _click(_button(\u0026#39;sign in\u0026#39;));  the following will happen under the hood:\n  _button creates a query with a locator to a button element and with 'sign in' as an identifier and an empty list of relations\n  this query is passed to the _click action. this action uses the accessorutil to fetch an element. it will:\n fetch a list of all elements from the locator reduce the list based on the relations (skipped when this list is empty) reduce the list with the identifier logic return the first entry of the remaining elements list    identifier the identifer is another relict from sahi that can be one of the following types:\n   type effect     number the identifier is considered as index. sakuli picks the element at this index (zero-based) in step 2.3   regexp tests this regexp against the following attributes of each element in the list at step 2.1: [aria-describedby], [name],  [id], classname, innertext, value, src   string the string is normalized and wrapped into a regexp, therefore the same logic as for regexp is applied   accessoridentifierattributes this could be an object with the properties sahiindex and/or sahiindex, sahitext, classname. the first two are handled like a number or a string identifer, respectively. the latter one works like a string identifier which only checks for the classname property     since we mostly apply the logic of sahi comparisons against the class attribute are pretty dumb. while the attribute value is semantically a space separated list of class names. it is just handled as a usual string in sahi (and therefore also in sakuli so far).\n action api the action api is described in the action api interface.\nactions usually invoke a selenium action sequence with an activated bridge mode to cover compatibility to most webdriver implementations. an action accepts a sahielementquery or a webelement and tries to perform the action on this element several times. this approach reduces the count of staleelementreferenceerrors dramatically, especially when a query is used.\n_eval beside the fact that actions work asynchronously now, they behave like in sahi. one exception is the _eval method, which accepts a string now containing some javascript code, which is performed on the website by the webdriver implementation (see executeasyncscript method of seleniums thenablewebdriver).\nconst windowouterheight = await _eval(`return window.outerheight`)  fetch api the fetch api is described in the fetch api interface.\nthese methods are useful to get deeper access to elements and element-attributes:\nconst [x,y] = await _position(_image(\u0026#39;funny-cat-image.png\u0026#39;));  or let you perform checks (e.g. if an element exists).\nif(await _exists(_div(\u0026#39;cookie-banner\u0026#39;))) { await _click(_button(\u0026#39;i agree\u0026#39;)) }  selenium fallbacks since sakuli uses seleniums webdriver it also provides various ways to access the functionality of this backend.\n it is recommended to use sakulis built-in functionalities rather than work with the driver instances or any webelement directly. at the moment, sakuli is built upon selenium. nevertheless, a switch to other technologies in the future is possible. downwards compatibility is only possible for sakulis built-in functionalities. direct use of webdriver instance methods is not supported.\n webdriver instance sakuli test scripts provide a globally accessible object of the current webdriver instance which can be used to invoke its native methods directly. this might be useful for switching between frames:\nawait driver.switchto().frame(1); await _click(_div(\u0026#39;element-in-frame-1\u0026#39;)); await driver.switchto().defaultcontent();  webelement instances the fetch api provides the _fetch function which returns the native webelement instance from seleniums webdriver for a query:\nconst webelement = await _fetch(_image(\u0026#39;funny-cat-image.png\u0026#39;)); const {width, height} = await webelement.getrect();  "
},
{
	"uri": "/docs/change_notes/",
	"title": "Change notes",
	"tags": [],
	"description": "",
	"content": "change notes -v2.3.0 -v2.4.0 "
},
{
	"uri": "/docs/writing_tests/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": "tutorial this tutorial shows how to set up a sakuli test using the cli and how to use a combination of the native and dom-based features of sakuli.\nsetting up a sakuli test suite sakuli will bootstrap a test suite with the following command. a detailed explanation on what files are needed, can be found in anatomy chapter. npx @sakuli/cli create project . --package npm i\ntypescript this step is optional but we recommend using typescript. for example, in case of a missing await typescript will throw an error during compilation. but this tutorial will also work if you decide to not use typescript.\nnpx sakuli enable-typescript . for typescript to find the respective test-files, you need to change the file extension from .js for javascript to .ts for typescript or create a new file. after doing so, it is necessary to update testsuite.suite for sakuli to find the testfile.\nnative-testing tutorial for this tutorial we will create a test that opens the 10 step guide to e2e monitoring whitepaper only using native interaction and download the document. as we only want to use native interaction we can set testsuite.uionly=true in the testsuite.properties.\nfirst we are going to open a chromium browser, navigate to the whitepaper section and download the whitepaper. (async () =\u0026gt; { const tc = new testcase(); const env = new environment(); const chromium = new application(\u0026#39;chromium-browser --incognito\u0026#39;); const screen = new region(); await tc.addimagepaths(\u0026#39;./assets\u0026#39;); try { await env.setsimilarity(0.99); await chromium.setsleeptime(3); await chromium.open(); await env.type(\u0026#39;sakuli.io/wp\u0026#39;) .type(key.enter) .getregionfromfocusedwindow() .waitforimage(\u0026#39;open_whitepaper.png\u0026#39;, 3) .mousemove() .click(); tc.endofstep(\u0026#39;open whitepaper\u0026#39;); } catch (e) { await tc.handleexception(e); } finally { tc.saveresult(); } })(); \nthe following section will describes the details of the test. as a first step we want to open the chromium browser and use incognito mode. this can be achieved by opening the application with the respective parameter: const chromium = new application('chromium-browser --incognito');\nas we are using multiple screenshot for this testcase, we will add them to a new folder and therefore eliminate cluttering of the testcase folder. hence you need to use tc.addimagepaths(\u0026quot;./assets\u0026quot;) to tell sakuli to look into this folder. the base directory during the sakuli test is the corresponding testcase folder.\nnext we are setting the similarity level for image recognition. the higher the value you choose, the higher the matching score must be. you can also change this within your test to react to different matching-score needs.\nas the operating system needs some time to start the application (in this case the browser), we will set a sleeptime.\nafter the chromium browser is opened the focus will be on the url-tab by default - we can just start typing the url we want to navigate to and hit enter. the next step is to get the region of the desktop and search for the icon of the whitepaper: after clicking the icon, the whitepaper pdf will be opened in a new tab. to verify whether the whitepaper was opened correctly, we try to find the following screenshot on the screen: to do so, we add the following lines to our test:\nawait env.setsimilarity(0.98); await screen.waitforimage(\u0026#39;whitepaper.png\u0026#39;, 3); tc.endofstep(\u0026#39;validate open whitepaper\u0026#39;);  as a last step we want to print this whitepaper as a pdf (saving it to the file-system). we can do this with the following code: await env.type(key.p, key.ctrl) .getregionfromfocusedwindow() .waitforimage(\u0026#34;print_dialog.png\u0026#34;,2) .mousemove() .click() .sleep(1) .type(\u0026#34;sakuli-tutorial\u0026#34;) .type(key.enter); tc.endofstep(\u0026#34;download whitepaper\u0026#34;); \nwith ctrl+p we open the print dialog which could look like this. now we need to move the mouse to the save button and click using this screenshot: afterwards another pop up dialog appears, which allows us to change the name of the pdf-file. for this instance we want to name it sakuli-tutorial. in the end we need to press enter to save the file.\nthe complete sakuli test should look like this:\n(async () =\u0026gt; { const tc = new testcase(); const env = new environment(); const chromium = new application(\u0026#39;chromium-browser --incognito\u0026#39;); const screen = new region(); await tc.addimagepaths(\u0026#39;./assets\u0026#39;); try { await env.setsimilarity(0.99); await chromium.setsleeptime(3); await chromium.open(); await env.type(\u0026#39;sakuli.io/wp\u0026#39;) .type(key.enter) .getregionfromfocusedwindow() .waitforimage(\u0026#39;open_whitepaper.png\u0026#39;, 3) .mousemove() .click(); tc.endofstep(\u0026#39;open whitepaper\u0026#39;); await env.setsimilarity(0.98); await screen.waitforimage(\u0026#39;whitepaper.png\u0026#39;, 3); tc.endofstep(\u0026#39;validate open whitepaper\u0026#39;); await env.type(key.p, key.ctrl) .getregionfromfocusedwindow() .waitforimage(\u0026#34;print_dialog_save.png\u0026#34;,2) .mousemove() .click() .sleep(1) .type(\u0026#34;sakuli-tutorial\u0026#34;) .type(key.enter); tc.endofstep(\u0026#34;download whitepaper\u0026#34;); await chromium.close(); } catch (e) { await tc.handleexception(e); } finally { tc.saveresult(); } })();  combining dom and native testing when the testsuite.uionly is set to false, you can use both dom based- and native interaction simultaneously. for our example above we can exchange the steps for opening chromium and navigating to sakuli.io/wp just with _navigateto(\u0026quot;https://sakuli.io/wp\u0026quot;) .\n(async () =\u0026gt; { const tc = new testcase(); const env = new environment(); const screen = new region(); await tc.addimagepaths(\u0026#39;./assets\u0026#39;); try { await env.setsimilarity(0.99); await _navigateto(\u0026#34;https://sakuli.io/wp\u0026#34;); await _click(_image(0, _in(_div(\u0026#34;flexedcontainer\u0026#34;)))); tc.endofstep(\u0026#39;open whitepaper\u0026#39;); await screen.waitforimage(\u0026#39;whitepaper.png\u0026#39;, 3); tc.endofstep(\u0026#39;validate open whitepaper\u0026#39;); await env.type(key.p, key.ctrl) .getregionfromfocusedwindow() .waitforimage(\u0026#34;print_dialog.png\u0026#34;,2) .mousemove() .click() .sleep(1) .type(\u0026#34;sakuli-tutorial\u0026#34;) .type(key.enter); tc.endofstep(\u0026#34;download whitepaper\u0026#34;); } catch (e) { await tc.handleexception(e); } finally { tc.saveresult(); } })();  "
},
{
	"uri": "/docs/writing_tests/migration-sakuli-1/",
	"title": "Migration from Sakuli 1",
	"tags": [],
	"description": "",
	"content": "how to migrate from sakuli 1 with sakuli v2+ we changed a lot under the hood and completely replaced the technology-stack. this resulted in a more flexible and future-ready architecture while preserving a maximum of backward compatibility. nearly all functions and classes from sakuli v1 are available in sakuli v2+. they are provided by the @sakuli/legacy package.\nasync / await you might have wondered where the await keyword came from when you saw the sakuli v2+ code. this resulted from the decision to use node.js as the new runtime for sakuli. the following section will describe the background of the async/await syntax and its use in sakuli. if you are already familiar with javascript, you can skip this section since it contains a lot of basic information.\nwhy we need it tl; dr;\n due to the runtime and core libraries, asynchronous operations are required (and cannot be turned into synchronous operations) async/await is the most idiomatic way to handle asynchronous code in javascript  if you ever worked with sakuli and followed our \u0026ldquo;getting started\u0026rdquo; guide, you might have noticed one of the most obvious paradigm changes regarding the test syntax: the wrapping (async () =\u0026gt; /*...*/)(); and the extensive use of await. this is due to the new runtime node.js and its asynchronous nature. node.js executes scripts in a single thread and therefore makes heavy use of asynchronous operations, avoiding to block the execution on this thread. the underlying javascript engine is v8 (which also powers the javascript execution in chromium browsers). to make this asynchronous behavior possible, v8 uses a so called \u0026ldquo;event-loop\u0026rdquo; with a \u0026ldquo;call-stack\u0026rdquo; containing all deferred operations (like: reading a file, making a web-request, doing heavy computation and so on). this talk explains this behavior in a short and entertaining way. a good illustration for the event loop is a (fast-food) restaurant, where you place an order at the counter and get a receiver that informs you when your food is ready. now you can do something else in the meantime while not blocking other processes or being blocked by them until you get your food and can do further operations (e.g. eat your meal).\nbut how does all this effect sakuli? sakuli v1 was running within a java virtual machine and the test scripts were executed within the rhino (javascript runtime for the jvm) - its fundamental treatment of asynchronous operations completely differs compared to node. simply said, everything in java is blocking until you make it non-blocking, while in node (many) operations are non-blocking by default. in java for example it is a rather common custom to run while-loops until the asynchronous operation sets its condition to false. this repl displays the basic idea: v8.\n\u0026ldquo;unfortunately\u0026rdquo;, it is not (easily) possible to turn non-blocking operations into blocking operations in node (have a look at this repl) and sakuli\u0026rsquo;s core technologies (selenium-webdriver and nut.js) make heavy use of asynchronous operations. there are tools like fibers that can help you, but they rely on native (os-dependent) libraries. therefore, we have decided to avoid another os specific library in sakuli.\nlast but not least: using and writing asynchronous code is the most idiomatic way to write javascript nowadays. using async/await is a kind of syntactic sugar, which lets us write asynchronous code like it would be synchronous just by using the await keyword. a short look back in the old days makes it clear how javascript landed there:\nback then, the most common way to handle asynchronous code was via callbacks. they were passed on to the asynchronous operation where they were executed as soon as the initial operation was finished. this approach was useful and acceptable for the usual javascript use-case during those days: handling events in the dom. but when node was released and many browser applications became more and more complex, the developers ended up with a so called callback hell. to exit this callback hell, es6 introduced the promise class. the advantage of a promise is its ability to chain with other promises, making it way more elegant to write subsequent, dependent asynchronous operations. a good read on this topic can be found on chapter viii of javascript for impatient programmers\nthe async wrapper you might have noticed that if a testcase in sakuli v2 is wrapped within (async () =\u0026gt; /*...*/)() this construct it is called immediately invoked function expression (iife). basically, it is the definition of a function that is immediately invoked. this pattern is widely used in javascript to preserve scopes and namespaces, since every symbol, which is defined at the top level of a script, becomes part of the global namespace and may potentially collide with other scripts. in the era of web bundler and es-modules this use-case became more and more irrelevant. iife on the other hand still remains important after the introduction of async/await in javascript. one caveat of this syntax is, that the await keyword is only available within an asynchronous function - because the engine will wrap the whole body of this function within a promise. that means, that in order to be able to make use of the await keyword, your code has to be executed within an asynchronous function. on the top level iife, we declare the actual function as async and can make use of await.\nif you want to avoid this construct completely, you can use the then function of a promise. the example code of the getting started guide would look like this then:\nconst testcase = new testcase(); _navigateto(\u0026#34;https://sakuli.io\u0026#34;) .then(_ =\u0026gt; testcase.endofstep(\u0026#34;open landing page\u0026#34;, 5, 10)) .then(_ =\u0026gt; _click(_link(\u0026#34;getting started\u0026#34;))) .then(_ =\u0026gt; _click(_link(\u0026#34;initialization\u0026#34;))) .then(_ =\u0026gt; _highlight(_code(\u0026#34;npm init\u0026#34;))) .then(_ =\u0026gt; testcase.endofstep(\u0026#34;find npm init code sample\u0026#34;)) .catch(e =\u0026gt; testcase.handleexception(e)) .then(_ =\u0026gt; testcase.saveresult());  this is also a totally valid format that can be used within sakuli. however, this approach has two downsides:\n if you are less familiar with javascript, it could become harder to read and understand the examples mentioned in the sakuli documentation will mostly use the await/async syntax  due to those reasons, we would advise you not to use the .then(...) syntax, unless you are completely sure about what you are doing.\nasync functions most functions which implement the sahi dsl - recognizable by a prefixed underscore - return a promise. that means, that you should put an await in front of it. exceptions from this pattern are accessor functions, which create query objects to access elements in the dom. you can check if the function returns a promise in the api docs of sahiapi. if you are not sure that you need an await, you can put it anyway since the function will be executed as expected. considering that this is not a good practice, we are working on tools which will help you identify async functions like typescript support.\nthenable classes sakuli has some classes - especially those for native interactions - which implement the fluent interface pattern, where you can chain method invocations on the same object. unfortunately, this does not really play nice with asynchronous operations. methods of a fluent api always return the object itself or at least an instance of the same class. but an asynchronous (and awaitable) method rather needs to return a promise. to still accomplish the goal of backward compatibility, all classes implementing a fluent interface and including asynchronous methods are wrapped in a thenable\u0026lt;classname\u0026gt; form of itself. this concept is highly inspired by selenium-webdrivers thenablewebdriver. from an end-user perspective, you can use the fluent interface almost like before, except of a little await at the beginning:\n// with thenable classes; assuming we are in the context of an async function await screen.find(\u0026#39;button.png\u0026#39;).click(); // without thenable class screen.find(\u0026#39;button.png\u0026#39;) .then(screen =\u0026gt; screen.click());  thenable classes are:\n application environment region  the technical trick behind this is, that there are two implementations: the actual class with the async functions and a thenable class, which implements the promiselike interface. the promiselike interface basically forces a then function to be implemented and is therefore \u0026ldquo;awaitable\u0026rdquo;. the wrapper class also holds a promise with the instance to the actual class. when a method of the thenable class is invoked, it delegates the call to the same method of the actual class and returns itself with the promise given back by the actual method. since the thenable class itself is a promise, it will resolve to an instance of the actual class.\n_include and _includedynamic if you ever wrote larger or different testcases on the same system, you might have come up with a modularization of commonly used functions. for example, the login to a system is always the same in all testcases, so you put it into a separate file.\nsakuli v1 includes functions to load these files into your actual testcase: _include or _includedynamic. the code usually looks like this:\n\u0026lt;testsuite\u0026gt;/common/login.js: function login($user, $password) { //... login logic } \n\u0026lt;testsuite\u0026gt;/testcase/case.js _include(\u0026#39;../commons/login.js\u0026#39;); try { var testcase = new testcase(\u0026#39;\u0026#39;); login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); // actual test code } catch(e) { testcase.handleexception(e); } finally { testcase.saveresults(); } \ntwo interesting aspects can be observed here:\n functions defined in the included script were added to the global namespace it is not an idiomatic way to require dependent code in javascript (nowadays)  sakuli now introduces support for es-module syntax. to adapt the example above, it has to be rewritten as follows:\n \u0026lt;testsuite\u0026gt;/common/login.js export async function login($user, $password) { //... login logic } \n \u0026lt;testsuite\u0026gt;/testcase/case.js import {login} from \u0026#39;./../commons/login\u0026#39;; try { var testcase = new testcase(\u0026#39;\u0026#39;); await login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); // actual test code } catch(e) { testcase.handleexception(e); } finally { testcase.saveresults(); } \nbeside the added async/await keywords, we can see that the first line of each script changed. in the first script, all functions (or classes, enums, constants, etc) have to be explicitly exported by the script (\u0026ldquo;module\u0026rdquo; would be a more accurate term) if they should be used in other scripts. for the actual testcase script the _include function will be removed and replaced by an import. the import ensures that we only import symbols that are required in the current script and its global namespace. each function required in the testcase script has to be imported explicitly. an alternative syntax is to import everything within its own namespace:\nimport * as loginutils from \u0026#39;./../commons/login\u0026#39;; // omitting boilerplate code  await loginutils.login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;);  "
},
{
	"uri": "/docs/enterprise_features/sakuli-dashboard-configuration/",
	"title": "Sakuli Dashboard Configuration",
	"tags": [],
	"description": "",
	"content": "sakuli dashboard configuration this section contains information on how to configure the sakuli dashboard.\nthe sakuli dashboard is configurable via environmental variables containing json documents. check out the different sections to get example templates and detailed information about how to set up your sakuli dashboard.\n   environment variable description     dashboard_config configures the displays (ordering, url, action buttons, etc.) shown in the dashboard   action_config (optional) available actions to perform on the cluster and corresponding display updates   cluster_config (optional) configures the cluster access (cluster address, access token, etc.)   cronjob_config (optional) configures a cronjob to schedule a specific action    the following picture shows a sakuli dashboard with an exemplary configuration and information about the different sections below.\n  when hovering over the info button you can see the configurable tool tip. this section represents the dashboards title. you can display content in german or english. it is possible to choose between a row or column layout of the displays.  dashboard_config the dashboard_config defines the order and description of displays and the resources to embed within the iframes. here is a sample dashboard_config for the sakuli dashboard.\n{ \u0026#34;displays\u0026#34;:[ { \u0026#34;index\u0026#34;:1, //1  \u0026#34;messages\u0026#34;: { //2  \u0026#34;de\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;ihr kubernetes service\u0026#34;, \u0026#34;infotext\u0026#34;: \u0026#34;lorem ipsum dolor sit amet\u0026#34; }, \u0026#34;en\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;your kubernetes service\u0026#34;, \u0026#34;infotext\u0026#34;: \u0026#34;lorem ipsum dolor sit amet\u0026#34; } }, \u0026#34;url\u0026#34;:\u0026#34;https://your-cluster.com\u0026#34;, //3  \u0026#34;actionidentifier\u0026#34;:\u0026#34;your_action_id_123\u0026#34; //4  }, { \u0026#34;index\u0026#34;:2, \u0026#34;messages\u0026#34;: { \u0026#34;de\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;dokumentation von sakuli\u0026#34; }, \u0026#34;en\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;documentation of sakuli\u0026#34; } }, \u0026#34;url\u0026#34;:\u0026#34;https://sakuli.io/docs\u0026#34; } ] }   the index defines the order for the displays on the sakuli dashboard. separated by language, the optional messages property specifies the title of a display using the description property and tool tip using the infotext property. the content can be displayed in german or english. the url property embeds the corresponding website in the iframe of the display. the actionidentifier property is optional and references to an action defined within the action_config.  action_config (optional) the action_config configures the actions triggered by users or cronjobs.\n{ \u0026#34;actions\u0026#34;:[ { \u0026#34;actionidentifier\u0026#34;:\u0026#34;your_action_id_123\u0026#34;, //1  \u0026#34;action\u0026#34;: { //2  \u0026#34;metadata\u0026#34;: { \u0026#34;labels\u0026#34;: { \u0026#34;app\u0026#34;: \u0026#34;sakuli\u0026#34; }, \u0026#34;name\u0026#34;:\u0026#34;sakuli\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;containers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;sakuli\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;taconsol/sakuli:latest\u0026#34;, \u0026#34;env\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;vnc_view_only\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;true\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;sakuli_encryption_key\u0026#34;, \u0026#34;valuefrom\u0026#34;: { \u0026#34;secretkeyref\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;sakuli-encryption-key\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;key\u0026#34; } } } ] } ], \u0026#34;restartpolicy\u0026#34;: \u0026#34;never\u0026#34; } } } ] }   action identifier that is referenced inside dashboard_config or cronjob_config. kubernetes/openshift pod template to be applied on the cluster. currently only pod configurations are supported.  important information: in order to apply actions to a cluster, a valid cluster_config must be provided.\ncluster_config (optional) the cluster_config is required to connect to an existing cluster where you want to execute your actions.\n{ \u0026#34;cluster\u0026#34;:{ //1  \u0026#34;name\u0026#34;:\u0026#34;sakuli/examplecluster-com:443/developer\u0026#34;, //2  \u0026#34;server\u0026#34;:\u0026#34;http://examplecluster.com:443\u0026#34; //3  }, \u0026#34;user\u0026#34;:{ //4  \u0026#34;name\u0026#34;:\u0026#34;developer\u0026#34;, \u0026#34;token\u0026#34;:\u0026#34;\u0026lt;login-token\u0026gt;\u0026#34; }, \u0026#34;namespace\u0026#34;:\u0026#34;sakuli\u0026#34; //5 }   cluster to execute actions on. cluster name. cluster address and port number. user to log onto cluster namespace to execute actions in.  important information: a valid cluster_config is required, as soon as you want to apply actions using action_config and/or cronjob_config to a cluster.\ncronjob_config (optional) { \u0026#34;schedule\u0026#34;: \u0026#34;*/20 * * * *\u0026#34;, \u0026#34;actionidentifier\u0026#34;: \u0026#34;your_action_id_123\u0026#34; }  schedules one action specified in action_config. the actionidentifier has to be set accordingly. the scheduling determined by the schedule property has to be specified according to the time format that is used by the gnu crontab format\nimportant information: in order to apply scheduled actions to a cluster, a valid action_config and cluster_config must be provided.\n"
},
{
	"uri": "/docs/enterprise_features/ocr/",
	"title": "Optical character recognition (OCR)",
	"tags": [],
	"description": "",
	"content": "optical character recognition (ocr) this feature is currently a tech preview!\nwith optical character recognition (ocr) it is possible to convert screen content into text. in combination with sakuli, it is also possible to automate software based on the text shown on screen.\nocr in enterprise containers sakuli enterprise containers ship with a complete setup to use the ocr features of sakuli. ocr features can be used without any further set up. please have a look at the enterprise containers documentation for more information about container usage.\ninstalling sakuli ocr installing the ocr module of sakuli on a workstation or virtual machine is possible, but requires some additional steps and dependencies. we recommend, to use the ready-to-use enterprise container for most use cases. a native installation should only be considered, if the enterprise containers don\u0026rsquo;t fit the requirements of your check.\nadd ocr module to package.json to add the ocr module, please add \u0026quot;@sakuli/ocr\u0026quot;: \u0026quot;next\u0026quot; to your package.json.\n{ \u0026#34;name\u0026#34;: \u0026#34;sakuli-project\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.8.15\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;sakuli run test-suite\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;@sakuli/cli\u0026#34;: \u0026#34;next\u0026#34;, \u0026#34;@sakuli/ocr\u0026#34;: \u0026#34;next\u0026#34; } } after altering your package.json, the module can be installed with npm install on command line.\n please make sure that you have access to the enterprise npm package repository as well as a valid license of level m or higher. for more information on how to set up your access to enterprise packages, please have a look at the enterprise features documentation.\n installing tesseract sakuli ocr uses tesseract to read text from the screen. for performance and quality reasons, a native installation of tesseract is required. please ensure to install a tesseract version \u0026gt;= 4.1.1. for more information on how to obtain and install tesseract on your machine, please have a look at the official tesseract documentation.\nextracting text from screen to read text from the screen, sakuli ocr ships with the test step _gettextfromregion(). the function returns all text on the screen including line feeds.\nreading the whole screen const text = await _gettextfromregion(new region()); reading text from a specific region const regiontoread = new region(50, 100, 400, 50); const textofregion = await _gettextfromregion(regiontoread); new region(50, 100, 400, 50); creates a region with the following specification:\n x = 50 px y = 100 px width: 400 px height: 50 px  the constant textofregion will only contain the text from this specific region of the screen.\nfinding a screen region by text with sakuli, it is also possible to automate software based on the text shown on the screen. _getregionbytext() provides the possibility to search for a specified text on the screen or in a specified region of the screen. once the location of the text is determined, it is possible to e.g. move the mouse to the location and click on it.\nawait _getregionbytext(\u0026#34;continue\u0026#34;).click(); this sample would search the screen for the text \u0026ldquo;continue\u0026rdquo; and subsequently click on it.\nconst searchregion = new region(50, 100, 400, 50); await _getregionbytext(\u0026#34;continue\u0026#34;, searchregion).click(); new region(50, 100, 400, 50); creates a region with the following specification:\n x = 50 px y = 100 px width: 400 px height: 50 px  in this sample, the search for the text \u0026ldquo;continue\u0026rdquo; would be limited to the specified screen region.\ncombining ocr features one common use case would be to extract text from a certain region of the screen e.g. from an offer or invoice for further validation.\n(async () =\u0026gt; { const testcase = new testcase(\u0026#34;check offer\u0026#34;); try { // ...  const offernumberregion = await _getregionbytext(\u0026#34;offer number\u0026#34;).grow(10); const offernumber = await _gettextfromregion(offernumberregion);  const expectedordernumber = /42-xbc-09453/; await _assert(promise.resolve(!!offernumber.match(expectedordernumber)), `found ${offernumber}instead of ${expectedordernumber}`); // ...  } catch (e) { await testcase.handleexception(e); } finally { await testcase.saveresult(); } })(); this check would search for the \u0026ldquo;offer number\u0026rdquo; in the pdf, extract the whole offer number and compare it to an expected value.\ntroubleshooting the quality of ocr results highly depends on the screen content. here are some aspects to consider when ocr does not recognize the text you expect:\n a lower screen resolution might help due to bigger fonts bigger fonts are better than smaller fonts high contrasts are helpful. reading yellow text from white background might cause issues.  in case you want to have some insights in what tesseract \u0026ldquo;sees\u0026rdquo; through a sakuli automation, you can easily adapt log levels to show details of the ocr process.\n debug level  provides the tesseract cli call for reconstruction purposes provides the tesseract config on cli level provide details on post processing of the screen content   trace level  writes the received text from _gettextfromregion() to the logs write the received alto xml from _getregionbytext() to the logs    known issues  there is currently a bug in an upstream library causing issues with ocr on macos.  "
},
{
	"uri": "/docs/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "the pinnacle of testing behavior and performance validation of basically every application. test like a real-world user!\n"
},
{
	"uri": "/docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
