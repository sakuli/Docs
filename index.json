[
{
	"uri": "/Docs/enterprise_features/icinga/",
	"title": "Icinga2 Forwarder",
	"tags": [],
	"description": "",
	"content": " Icinga2 Forwarder Add the forwarder to your project with:\nnpm i @sakuli/forwarder-icinga2 To register the forwarder into your project you have to edit the package.json file and add the preset to the Sakuli configuration key:\n{ \u0026#34;sakuli\u0026#34;: { \u0026#34;presetProvider\u0026#34;: [ \u0026#34;@sakuli/legacy\u0026#34;, \u0026#34;@sakuli/forwarder-icinga2\u0026#34; ] } } Installation of any enterprise feature requires a proper setup of your license information. You can find further information in theenterprise section.\nEnable the Icinga2 API All steps required to enable the Icinga2 API are described in the REST API documentation.\nCreate a Icinga2 service Create a check_command which will only be executed if Icinga2 did not receive a Sakuli result within a certain time. This ensures that you get a notification even if no passive check result reaches Icinga2 at all:\n/etc/icinga2/conf.d/commands.conf object CheckCommand \u0026#34;check_dummy\u0026#34; { import \u0026#34;plugin-check-command\u0026#34; command = [ PluginDir + \u0026#34;/check_dummy\u0026#34;,\u0026#34;$dummy_state$\u0026#34;,\u0026#34;$dummy_text$\u0026#34; ] vars.dummy_state = 0 vars.dummy_text = \u0026#34;Check was successful.\u0026#34; } object CheckCommand \u0026#34;check_sakuli\u0026#34; { import \u0026#34;check_dummy\u0026#34; vars.dummy_state = 3 vars.dummy_text = \u0026#34;No passive Sakuli check result received.\u0026#34; }\n/etc/icinga2/conf.d/hosts.conf object Host \u0026#34;sakuliclient01\u0026#34; { import \u0026#34;generic-host\u0026#34; address = \u0026#34;\u0026lt;IP\u0026gt;\u0026#34; }\nCreate the following service object for the first testcase. The freshness_threshold should be slightly higher than the interval Sakuli tests are planned.\nobject Service \u0026#34;sakuli_demo\u0026#34; { import \u0026#34;generic-service\u0026#34; host_name = \u0026#34;sakuliclient01\u0026#34; check_command = \u0026#34;check_sakuli\u0026#34; enable_active_checks = 0 enable_passive_checks = 1 enable_flapping = 0 volatile = 1 enable_perfdata = 1 } Reload Icinga2:\nservice icinga2 reload After opening Icingaweb2 you should see the Sakuli host with the service \u0026ldquo;sakuli_demo\u0026rdquo; attached.\nThe check is waiting now for check results from a Sakuli client.\nSakuli Client Configuration You must set the global properties for the Icinga2 receiver on the Sakuli client by editing the sakuli.properties. You can find them in the folder containing the testsuites:\n   Property Default Effect     sakuli.forwarder.icinga2.enabled false Enables result forwarding to Icinga2   sakuli.forwarder.icinga2.api.host  The hostname or IP of the Icinga2 API-endpoints   sakuli.forwarder.icinga2.api.port 5665 The port or IP of the Icinga2 API-endpoints   sakuli.forwarder.icinga2.api.username  API user name   sakuli.forwarder.icinga2.api.password  API user password   sakuli.forwarder.icinga2.hostname  The name of the host object configured in Icinga2   sakuli.forwarder.icinga2.service_description ${testsuite.id} The name of the service in Icinga2   sakuli.forwarder.icinga2.allow_insecure_connection false Disable SSL checks. Never use this in production environments!    "
},
{
	"uri": "/Docs/start/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": " What you need Sakuli is built and tested against the current LTS version of Node.js. In order to be able to run Sakuli on your system, we will assume that you have a Node v10.15.3 (lts/dubnium) installed on it.\nTo install Node on your system, you can either go to the Node website or you can use tools like Node Version Manager, a utility to manage various Node versions on a per-user basis. In general, a per-user installation is the preferred way since it runs in an unprivileged mode.\n"
},
{
	"uri": "/Docs/start/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "hello (async () =\u0026gt; { // 1 const testCase = new TestCase(); // 2 try { // actual test code goes here } catch (e) { await testCase.handleException(e); // 3 } finally { await testCase.saveResult(); // 4 } })().then(done); // 5\n"
},
{
	"uri": "/Docs/enterprise_features/check/",
	"title": "Check MK Fowarder",
	"tags": [],
	"description": "",
	"content": " Check_MK Forwarder Add the forwarder to your project with:\nnpm i @sakuli/forwarder-checkmk To register the forwarder into your project you have to edit the package.json file and add the preset to the Sakuli configuration key:\n{ \u0026#34;sakuli\u0026#34;: { \u0026#34;presetProvider\u0026#34;: [ \u0026#34;@sakuli/legacy\u0026#34;, \u0026#34;@sakuli/forwarder-checkmk\u0026#34; ] } } Installation of any enterprise feature requires a proper setup of your license information. You can find further information in the enterprise section.\nSakuli Client Configuration It is assumed that the client is already monitored by Check_MK and that an agent is installed and running on it.\nSpool folder Create a new folder spool in the installation path of the Check_MK agent. This is the folder where the results will be written and stored into. Don\u0026rsquo;t forget to grant writing permissions for the folder to the user running Sakuli checks.\nForwarder configuration Now you have to set up the properties for the Check_MK receiver. In order to do this, edit the sakuli.properties in the folder containing the testsuites:\n   Property Default Effect     sakuli.forwarder.check_mk.enabled false Enables writing to the spool file   sakuli.forwarder.check_mk.spooldir /var/lib/check_mk_agent/spool (Linux)\u0026lt;CMK_installation_path\u0026gt;\\\\spool (Windows) Path to the spool folder as defined above. On Windows, the backslashes have to be escaped with \u0026lsquo;\\\u0026lsquo;. Check_MK is expecting the result files from Sakuli in here   sakuli.forwarder.check_mk.freshness 600 Defines the maximal age in seconds for which the result is still valid. If the last modification of the result file is older than this property, the result file will be ignored. The Check_MK service will turn into UNKNOWN   sakuli.forwarder.check_mk.spoolfile_prefix sakuli_suite_ Defines the result file prefix. It can be used to change the default naming convention for the Check_MK output files   sakuli.forwarder.check_mk.service_description ${testsuite.id} Defines the service description which is used within the check result   sakuli.forwarder.check_mk.piggyback_hostname local Defines Hostname for check results, configurable for piggyback results   sakuli.forwarder.check_mk.output.details true Dis- / Enables detailed HTML output    An example configuration could look like this:\nsakuli.forwarder.check_mk.enabled=true sakuli.forwarder.check_mk.spooldir=/var/lib/check_mk_agent/spool sakuli.forwarder.check_mk.freshness=600 sakuli.forwarder.check_mk.spoolfile_prefix=sakuli_suite_ sakuli.forwarder.check_mk.service_description=My_Custom_Service sakuli.forwarder.check_mk.piggyback_hostname=MyHost "
},
{
	"uri": "/Docs/writing_tests/anatomy/",
	"title": "Anatomy",
	"tags": [],
	"description": "",
	"content": " Anatomy of a Project This guide assumes that you have finished the \u0026ldquo;Getting started\u0026rdquo; tutorial or that you are experienced with Sakuli v1.\n Most of the complexity and conventions are due to the backwards compatibility to v1, which requires a specific folder and file structure for various reasons (the biggest is Sahi). Sakuli offers now various ways to reduce this complexity dramatically. These features will eventually become part of upcoming releases.\n Setup and configuration The minimum setup for a Sakuli project looks like this:\n  your-sakuli-project Home folder of the project   package.json All dependencies and setups for Node.js  sakuli.properties (optional: Configuration for all testsuites)  testsuite-a Home folder of a testsuite   testsuite.suite Defines which testcases belong to the testsuite  testsuite.properties Configuration for the testsuite (overrides configuration from \u0026lsquo;../sakuli.properties\u0026rsquo;)  testcase Home of the testcase   testcase.js The actual testcase     This file layout also represents the logical structure of Sakuli, which consists of a testsuite with one or more testcase(s). Sakuli\u0026rsquo;s run command takes the path to a testsuite folder and runs all testcases defined in testsuite.suite of the given folder.\ntestsuite.suite This file is a relic from Sahi where you define testcases and their respective start-urls. It has a simple format:\n\u0026lt;CASE-PATH\u0026gt;/\u0026lt;CASE-FILE\u0026gt; \u0026lt;START-URL\u0026gt;  \u0026lt;CASE-PATH\u0026gt; is a path within the testsuite file, which has to contain the file \u0026lt;CASE_FILE\u0026gt;. The \u0026lt;START-URL\u0026gt; is no longer used by Sakuli (but required to fulfil the file format). The format also supports comments (// at the beginning of a line). Testcases can be activated or deactivated by using comments.\n The configured start-url is omitted to force test authors to write explicit navigation to the url for testcases using _navigateTo.\n Properties Files Each testsuite requires a testsuite.properties file with at least one entry:\ntestsuite.id=SomeName  It \u0026ldquo;inherits\u0026rdquo; its values from ../sakuli.properties (which also means that the same property from sakuli.properties becomes overridden).\n Property files are a common way to store configuration in Java, the former runtime for Sakuli. It is a simple key-value format (\u0026lt;KEY\u0026gt;=\u0026lt;VALUE\u0026gt;) where every line defines a key-value pair. To organize the keys, it is a common - but not required - practice to separate names by dots (similar to Java namespaces).\n There are several predefined properties that can be configured to influence the behavior of Sakuli (* indicates a required property):\n   Property Type: Default Comment / Example     testsuite.id String*: / Name of the suite shown in the output and used by the forwarder   testsuite.browser String: \u0026lsquo;firefox\u0026rsquo; Browser which is started by the WebDriver (it can be overridden by the --browser command line argument)    You can also define own properties and use them in your testcases. Just put your custom property key with the corresponding value in one of the .property files and into your testcase. You can retrieve the values with help of the Environment Class:\n// omitting boilerplate // assuming you have added // user.name=Tester // in one of the property files const env = new Environment(); await _setValue(_textbox(\u0026#39;username\u0026#39;), env.getProperty(\u0026#39;user.name\u0026#39;));  "
},
{
	"uri": "/Docs/start/initialization/",
	"title": "Initialization",
	"tags": [],
	"description": "",
	"content": " Initialize a project This guide will get you started with writing Sakuli tests from scratch. To follow this tutorial, you should create a new NPM project in an empty folder.\nFor this guide, we will assume that our working directory is /tmp/sakuli_starter on a *nix system, or %Temp%\\sakuli_starter on a Windows machine.\nTo create a new, empty project, first run:\nnpm init This interactive prompt will ask you for some metadata regarding your project. You can either modify these fields to your needs or just accept the defaults.\nOnce completed, you should see a short summary similar to the following snippet:\nAbout to write to /tmp/sakuli_starter/package.json: { \u0026#34;name\u0026#34;: \u0026#34;sakuli_starter\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } Is this OK? (yes) The empty project has been initialized after confirming the prompt.\n"
},
{
	"uri": "/Docs/writing_tests/",
	"title": "Writing Tests",
	"tags": [],
	"description": "",
	"content": " How to write Tests With Sakuli v2+ we changed a lot under the hood and completely replaced the technology-stack. This resulted in a more flexible and future-ready architecture while preserving a maximum of backward compatibility.\nMajor Changes to Sakuli v1 (Migration) Nearly all functions and classes from Sakuli v1 are available in Sakuli v2+. They are provided by the @sakuli/legacy package.\nAsync / Await You might have wondered where the await keyword came from when you saw the Sakuli v2+ code. This resulted from the decision to use Node.js as the new runtime for Sakuli. The following section will describe the background of the async/await syntax and its use in Sakuli. If you are already familiar with JavaScript, you can skip this section since it contains a lot of basic information.\nWhy we need it TL; DR;\n Due to the runtime and core libraries, asynchronous operations are required (and cannot be turned into synchronous operations) Async/Await is the most idiomatic way to handle asynchronous code in JavaScript  If you ever worked with Sakuli and followed our \u0026ldquo;Getting started\u0026rdquo; guide, you might have noticed one of the most obvious paradigmatic changes regarding the test syntax: The wrapping (async () =\u0026gt; /*...*/)().then(done) and the extensive use of await. This is due to the new runtime Node.js and its asynchronous nature. Node.js executes scripts in a single-thread and therefore makes heavy use of asynchronous operations avoiding to block the execution within the thread. The underlying JavaScript engine is V8 (which also powers the JavaScript execution in Chromium Browsers). To make this asynchronous behavior possible, V8 uses a so called \u0026ldquo;Event-Loop\u0026rdquo; with a \u0026ldquo;Call-Stack\u0026rdquo; containing all deferred operations (like: reading a file, making a web-request, doing heavy computation and so on). This talk explains this behavior in a short and entertaining way. A good illustration for the event loop is a (fast-food) restaurant, where you place an order at the counter and get a receiver that informs you when your food is ready. Now you can do something else in the meantime while not blocking other processes or being blocked by them until you get your food and can do further operations (e.g. eat your meal).\nBut how does all this effect Sakuli? Sakuli v1 was running within a Java Virtual Machine and the test scripts were executed within the Rhino-Engine (JavaScript Runtime for the JVM) - its fundamental treatment of asynchronous operations completely differs compared to Node. Simply said, everything in Java is blocking until you make it non-blocking, while in Node (many) operations are non-blocking by default. In Java for example it is a rather common custom to run while-loops until the asynchronous operation sets its condition to false. This repl displays the basic idea: Java version.\n\u0026ldquo;Unfortunately\u0026rdquo;, it is not (easily) possible to turn non-blocking operations into blocking operations in Node (have a look at this repl) and Sakuli\u0026rsquo;s core technologies (Selenium-WebDriver and nut.js) make heavy use of asynchronous operations. There are tools like fibers that can help you, but they rely on native (OS-dependent) libraries. Therefore, we have decided to avoid another OS specific library in Sakuli.\nLast but not least: Using and writing asynchronous code is the most idiomatic way to write JavaScript nowadays. Using async/await is a kind of syntactic sugar, which lets us write asynchronous code like it would be synchronous just by using the await keyword. A short look back in the old days makes it clear how JavaScript landed there:\nBack then, the most common way to handle asynchronous code was via callbacks. They were passed on to the asynchronous operation where they were executed as soon as the initial operation was finished. This approach was useful and acceptable for the usual JavaScript use-case during those days: Handling events in the DOM. But when Node was released and many browser applications became more and more complex, the developers ended up with a so called \u0026ldquo;callback hell\u0026rdquo;. To exit this callback hell, ES6 introduced the Promise class. The advantage of a Promise is its ability to chain with other Promises, making it way more elegant to write subsequent, dependent asynchronous operations. A good read on this topic can be found on chapter VIII of JavaScript for impatient programmers\nThe async wrapper You might have noticed that if a testcase in Sakuli v2 is wrapped within (async () =\u0026gt; /*...*/)().then(done) this construct it is called Immediately Invoked Function Expression (IIFE). Basically, it is the definition of a function that is immediately invoked. This pattern is widely used in JavaScript to preserve scopes and namespaces, since every symbol, which is defined at the top level of a script, becomes part of the global namespace and may potentially collide with other scripts. In the era of web bundler and ES-modules this use-case became more and more irrelevant. IIFE on the other hand still remains important after the introduction of async/await in JavaScript. One caveat of this syntax is, that the await keyword is only available within an asynchronous function - because the engine will wrap the whole body of this function within a Promise. That means, that in order to be able to make use of the await keyword, your code has to be executed within an asynchronous function. On the top level IIFE, we declare the actual function as async and can make use of await. Since the result of this function is automatically turned into a Promise, we can invoke then and pass the done function to it. done is a Sakuli specific function, which indicates to Sakuli that the testcase script is finished. There is currently a discussion on the JavaScript proposal in stage 3, which would introduce a top level await in JavaScript.\nIf you want to avoid this construct completely, you can use the then function of a Promise. The example code of the \u0026ldquo;Getting started\u0026rdquo; guide would look like this then:\nconst testCase = new TestCase(); _navigateTo(\u0026#34;https://sakuli.io\u0026#34;) .then(_ =\u0026gt; testCase.endOfStep(\u0026#34;Open Landing Page\u0026#34;, 5, 10)) .then(_ =\u0026gt; _click(_link(\u0026#34;Getting started\u0026#34;))) .then(_ =\u0026gt; _highlight(_code(\u0026#34;npm init\u0026#34;))) .then(_ =\u0026gt; testCase.endOfStep(\u0026#34;Find npm init code sample\u0026#34;)) .catch(e =\u0026gt; testCase.handleException(e)) .then(_ =\u0026gt; testCase.saveResult()) .then(done); This is also a totally valid format that can be used within Sakuli. However, this approach has two downsides:\n If you are less familiar with JavaScript, it could become harder to read and understand The examples mentioned in the Sakuli documentation will mostly use the await/async syntax  Due to those reasons, we would advise you not to use the .then(...) syntax, unless you are completely sure about what you are doing.\nAsync Functions Most functions which implement the Sahi DSL - recognizable by a prefixed underscore - return a Promise. That means, that you should put an await in front of it. Exceptions from this pattern are Accessor functions, which create query objects to access elements in the DOM. You can check if the function returns a Promise in the API docs of SahiAPI. If you are not sure that you need an await, you can put it anyway since the function will be executed as expected. Considering that this is not a good practice, we are working on tools which will help you identify async functions like Typescript support.\nThenable Classes Sakuli has some classes - especially those for native interactions - which implement the Fluent Interface pattern, where you can chain method invocations on the same object. Unfortunately, this does not really play nice with asynchronous operations. Methods of a fluent API always return the object itself or at least an instance of the same class. But an asynchronous (and awaitable) method rather needs to return a Promise. To still accomplish the goal of backward compatibility, all classes implementing a fluent interface and including asynchronous methods are wrapped in a Thenable\u0026lt;ClassName\u0026gt; form of itself. This concept is highly inspired by Selenium-WebDrivers ThenableWebDriver. From an end-user perspective, you can use the fluent interface almost like before, except of a little await at the beginning:\n// With Thenable classes; Assuming we are in the context of an async function await screen.find(\u0026#39;button.png\u0026#39;).click(); // Without Thenable class screen.find(\u0026#39;button.png\u0026#39;) .then(screen =\u0026gt; screen.click()); Thenable Classes are:\n Application Environment Region  The technical trick behind this is, that there are two implementations: The actual class with the async functions and a thenable class, which implements the PromiseLike interface. The PromiseLike interface basically forces a then function to be implemented and is therefore \u0026ldquo;awaitable\u0026rdquo;. The wrapper class also holds a Promise with the instance to the actual class. When a method of the thenable class is invoked, it delegates the call to the same method of the actual class and returns itself with the Promise given back by the actual method. Since the thenable class itself is a Promise, it will resolve to an instance of the actual class.\n_include and _includeDynamic If you ever wrote larger or different testcases on the same system, you might have come up with a modularization of commonly used functions. For example, the login to a system is always the same in all testcases, so you put it into a separate file.\nSakuli v1 includes functions to load these files into your actual testcase: _include or _includeDynamic. The code usually looks like this:\n\u0026lt;TESTSUITE\u0026gt;/common/login.js: function login($user, $password) { //... login logic }\n\u0026lt;TESTSUITE\u0026gt;/testcase/case.js _include(\u0026#39;../commons/login.js\u0026#39;); try { var testcase = new TestCase(\u0026#39;\u0026#39;); login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); // actual test code } catch(e) { testcase.handleException(e); } finally { testcase.saveResults(); }\nTwo interesting aspects can be observed here:\n Functions defined in the included script were added to the global namespace It is not an idiomatic way to require dependent code in JavaScript (nowadays)  Sakuli now introduces support for ES-module syntax. To adapt the example above, it has to be rewritten as follows:\n \u0026lt;TESTSUITE\u0026gt;/common/login.js export async function login($user, $password) { //... login logic }\n \u0026lt;TESTSUITE\u0026gt;/testcase/case.js import {login} from \u0026#39;./../commons/login\u0026#39;; try { var testcase = new TestCase(\u0026#39;\u0026#39;); await login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); // actual test code } catch(e) { testcase.handleException(e); } finally { testcase.saveResults(); }\nBeside the added async/await keywords, we can see that the first line of each script changed. In the first script, all functions (or classes, enums, constants, etc) have to be explicitly exported by the script (\u0026ldquo;module\u0026rdquo; would be a more accurate term) if they should be used in other scripts. For the actual testcase script the _include function will be removed and replaced by an import. The import ensures that we only import symbols that are required in the current script and its global namespace. Each function required in the testcase script has to be imported explicitly. An alternative syntax is to import everything within its own namespace:\nimport * as loginUtils from \u0026#39;./../commons/login\u0026#39;; // omitting boilerplate code  await loginUtils.login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); "
},
{
	"uri": "/Docs/enterprise_features/",
	"title": "Enterprise Features",
	"tags": [],
	"description": "",
	"content": " Enterprise Features Some features of Sakuli require an enterprise license. Please consult our overview to see and request packages and prices. After you registered for an enterprise subscription, you will get a license-key and an NPM access token which are required to use enterprise features.\nUsing License Information With your active Sakuli Enterprise subscription you will receive an email with:\n Sakuli license-key - Contains information about your subscription and is used by Sakuli itself and a NPM-Token - Allows access to Sakuli\u0026rsquo;s private enterprise packages on NPM  There are several ways to handle these information. The most simple way for setting up your enterprise features is as follows (substitute the placeholders between the chevrons with the appropriate values):\nGlobal configuration The most simple way to get your enterprise features to work is the following configuration (substitute the placeholders marked by the angle-brackets with its appropriate values):\nOn Unix / OSX echo \u0026#34;//registry.npmjs.org/:_authToken=\u0026lt;Put your personal NPM-TOKEN here\u0026gt;\u0026#34; \u0026gt; ~/.npmrc echo \u0026#34;export SAKULI_LICENSE_KEY=\u0026lt;Put your personal SAKULI-LICENSE-KEY here\u0026gt;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc\nOn Windows echo //registry.npmjs.org/:_authToken=\u0026lt;Put your personal NPM-TOKEN here\u0026gt; \u0026gt; %USERPROFILE%\\.npmrc setx SAKULI_LICENSE_KEY=\u0026lt;Put your personal SAKULI-LICENSE-KEY here\u0026gt;\nThe environment variables might not take effect in the command-line window where the commands above are entered. So you might need to open a new commandline when running the Sakuli command.\nThese commands will set the NPM-Token and License Key globally. This is good for a first setup on your machine but might have some shortcomings in more advanced situations. The following paragraphs describe alternative ways to provide NPM-Token and License information to your Sakuli installation.\nNow you are ready to go for using Sakuli with its enterprise features like\n Check_MK Icinga2 OMD  Per-Project configuration of NPM-Token You can set the NPM-Token for each project by adding a .npmrc file to your project\u0026rsquo;s root directory:\nOn Unix / OSX # cd path/to/project echo \u0026#34;//registry.npmjs.org/:_authToken=\u0026lt;Put your personal NPM-TOKEN here\u0026gt;\u0026#34; \u0026gt; .npmrc\nOn Windows # cd path/to/project echo //registry.npmjs.org/:_authToken=\u0026lt;Put your personal NPM-TOKEN here\u0026gt; \u0026gt; .npmrc\nThis command will create an .npmrc file with the necessary token configuration inside your specific project folder. Every upcoming npm install will use this configuration.\nPer-Project configuration with environment variable If you don\u0026rsquo;t like to save the token in a file (because this file might be shared) you can configure it to use an environment variable:\nOn Unix / OSX echo \u0026#34;//registry.npmjs.org/:_authToken=\\${NPM_TOKEN}\u0026#34; \u0026gt; ~/.npmrc\nOn Windows echo //registry.npmjs.org/:_authToken=${NPM_TOKEN} \u0026gt; %USERPROFILE%\\.npmrc\nOn Unix / OSX NPM_TOKEN=\u0026lt;Put your personal NPM-TOKEN here\u0026gt; npm i \u0026lt;ENTERPRISE-PACKAGE\u0026gt;\nOn Windows set NPM_TOKEN=\u0026lt;Put your personal NPM-TOKEN here\u0026gt; npm i \u0026lt;ENTERPRISE-PACKAGE\u0026gt;\nThis approach is frequently used in automation scenarios such as CI/CD pipelines and projects that are shared (e.g. via version control systems).\nIt is usually not necessary to persist the token since you will seldomly run npm install that often.\nUsing the License-Key The license-key contains information about your subscription which will be checked by enterprise components before they are executed. In order to provide this License-Key to Sakuli you also have to set it as an environment variable. Because the license-key is read on every single test execution it is useful to store it persistently on your system or set it in a script where the actual test is also called.\nThe name of the environment variable for the license-key is SAKULI_LICENSE_KEY.\nMore about Environment Variables  An environment variable is a dynamic-named value that can affect the way running processes will behave on a computer. They are part of the environment in which a process runs. For example, a running process can query the value of the TEMP environment variable to discover a suitable location to store temporary files, or the HOME or USERPROFILE variable to find the directory structure owned by the user running the process.\n - Wikipedia, 08/2019\nSo basically an environment variable is just a simple key-value pair provided to a certain process e.g. VAR_NAME=VALUE. They can be set for each process or system-wide - so that they become accessible for each upcoming process.\nThe approach for integrating an environment variable depends on the respective operating system.\nOn Windows To set up an environment variable on Windows you have to:\n Open Start-Menu and type env into the search mask  An entry \u0026lsquo;Edit the system environment variables\u0026rsquo; should appear (click on it)  After the System Properties dialog showed up  Go to the Advanced tab Click on the button Environment Variables (at the bottom of the dialog)  You should see two tables including Variable and Value columns for User Variables and System variables  There you can set, edit or delete environment variables permanently on your system (it is recommended to edit the system variables table if possible). A more detailed guide can be found here.\nAlternatively you can use Rapid Environment Editor which is a nice tool for editing environment variables on Windows.\nIn case of a more restrictive environment - where it is not possible to edit environment variables that easily - you can set them in a batch script:\nrun-sakuli.bat SET SAKULI_LICENSE_KEY=\u0026lt;PERSONAL_LICENSE\u0026gt; sakuli run .\nOn Linux or OSX On Linux or OSX it is usually a file which sets up the environment for certain processes:\n ~/.bashrc on Linux ~/.profile on OSX  These files can be changed with every text editor to add, edit or remove environment variables. An environment variable is defined by:\nexport VARIABLE_NAME=VALUE A new variable can be added with the command:\necho \u0026#34;export VARIABLE_NAME=VALUE\u0026#34; \u0026gt;\u0026gt; ~/.bashrc # Linux echo \u0026#34;export VARIABLE_NAME=VALUE\u0026#34; \u0026gt;\u0026gt; ~/.profile # OSX "
},
{
	"uri": "/Docs/enterprise_features/omd/",
	"title": "OMD Forwarder",
	"tags": [],
	"description": "",
	"content": " OMD / Gearman Forwarder Install the forwarder to your project with:\nnpm i @sakuli/forwarder-gearman To register the forwarder into your project you have to edit the package.json file and add the preset to the Sakuli configuration key:\n{ \u0026#34;sakuli\u0026#34;: { \u0026#34;presetProvider\u0026#34;: [ \u0026#34;@sakuli/legacy\u0026#34;, \u0026#34;@sakuli/forwarder-gearman\u0026#34; ] } } Installation of any enterprise feature requires a proper setup of your license information. You can find further information in the enterprise section.\nConfigure OMD Sakuli transmits performance data to a Gearman result queue rather than to OMD directly. For that we require a gearman-enabled monitoring system in an OMD environment.\nIt takes a few steps to set up the monitoring system in order to process Sakuli\u0026rsquo;s performance data correctly.\nEnable and configure mod-gearman Use the Makefile located in OMD_ROOT/share/sakuli/omd/ to configure mod-gearman:\n Enable all services for mod-gearman Set the bind IP and port (default: 0.0.0.0:4730; overwrite with e.g. export GEARMAN_PORT=192.168.130.10:4731) Set the encryption key (default: sakuli_secret; overwrite with e.g. export GEARMAN_SECRET=mykey)  Then run:\nsu - \u0026lt;SITE_USER\u0026gt; cd ~/share/sakuli/setup/omd make gearman Due to security reasons, the Makefile will only configure mod-gearman if it is not enabled yet. If it is already enabled inspect the Makefile, read the instruction carefully and execute the steps by hand.\nFor PRODUCTION usage please use individual encryption keys!\nIf you do not want to use encryption at all, enable accept_clear_results and disable sakuli.forwarder.gearman.encryption:\nvim ~/etc/mod-gearman/server.cfg ... accept_clear_results=yes testsuite.properties sakuli.forwarder.gearman.encryption=false\nGearman proxy (optional) Use the Sakuli gearman proxy script if you want to intervene between the communication of Sakuli and Naemon/Nagios.\nPossible use cases:\n Changes parts of the messages Sakuli sends to the monitoring system ⇒ there are some examples contained already Getting notified when Sakuli sends results to services that do not exist Auto-create services for incoming results (not yet implemented)  Use the Makefile located in $OMD_ROOT/share/sakuli/ to enable the feature:\nsu - \u0026lt;SITE_USER\u0026gt; cd n/share/sakuli/setup/omd make gearman_proxy Edit etc/mod-gearman/sakuli_gearman_proxy.cfg :\n$remoteHost=\u0026#34;172.17.0.2\u0026#34;; #1 $remotePort=\u0026#34;4730\u0026#34;; #1 $localHost=\u0026#34;172.17.0.2\u0026#34;; #2 $localPort=\u0026#34;4730\u0026#34;; #2 $queues = { \u0026#34;$remoteHost:$remotePort/check_results_sakuli\u0026#34; =\u0026gt; \u0026#34;$localHost:$localPort/check_results\u0026#34;, }; #3 + 4 $err_h = \u0026#39;error_host\u0026#39;; #5 $err_s = \u0026#39;eror_svc\u0026#39;; $err_r = \u0026#39;2\u0026#39;; #6  Gearman IP/Port listening for Sakuli results. Set this to the same values as  unless gearman_proxy.pl is running on another system Gearman IP/Port for the monitoring system check_results_sakuli ⇒ queue name to receive Sakuli results. Make sure this queue name is defined in property sakuli.forwarder.gearman.server.queue on all Sakuli clients (see Sakuli Client Configuration) check_results ⇒ default queue of mod-gearman where gearman workers write back their results (no need to change that) The proxy does a live status query for each incoming package to ensure that the receiving host/service exists. It provides a special \u0026ldquo;error host/service\u0026rdquo; pair where the proxy can send a message in case of results coming back for non-existent services Status of the messages for non-existent services (2 = CRITICAL)  su - \u0026lt;SITE_USER\u0026gt; omd start sakuli_gearman_proxy # Starting sakuli_gearman_proxy...OK Check that the queue check_results_sakuli is running in addition to the default queue check_results.\nOMD[demo]:~$ gearman_top 2017-06-09 13:37:28 - localhost:4730 - v0.33 Queue Name | Worker Available | Jobs Waiting | Jobs Running ----------------------------------------------------------------------- check_results | 1 | 0 | 0 check_results_sakuli | 1 | 0 | 0 ----------------------------------------------------------------------- This change does affect other monitoring checks executed with mod-gearman, because only Sakuli will send results into the queue check_results_sakuli.\nCreate a Nagios service Create a service which should receive Sakuli test results. Host/service names derive from the following properties:\n Host: sakuli.forwarder.gearman.nagios.hostname (defined globally or via suite) Service: testsuite.id (defined in testsuite.properties)  OMD configuration:\ndefine host { host_name sakuli_client alias sakuli_client address __SAKULI_CLIENT_IP__ use generic-host } define service { service_description example_xfce host_name sakuli_client use tpl_s_sakuli_gearman freshness_threshold 180 }  The freshness_threshold should be slightly higher than the interval during which Sakuli tests are executed.\n The check is waiting now for check results from a Sakuli client.\nSakuli Configuration You must set the global properties for the gearman receiver on the Sakuli client. For doing this, edit sakuli.properties in the folder containing the testsuites:\n   Property Default Effect     sakuli.forwarder.gearman.enabled false Enable forwarding to OMD   sakuli.forwarder.gearman.encryption true Enable encryption and set the key only if you did not activate accept_clear_results in mod-gearman. Otherwise, set encryption to false   sakuli.forwarder.gearman.secret.key secret-password The password configured in enable and configure mod-gearman   sakuli.forwarder.gearman.server.host  The host where OMD is running   sakuli.forwarder.gearman.server.port 4730 The port where gearman is listing (configured in enable and configure mod-gearman)   sakuli.forwarder.gearman.server.queue check_results The default queue for Sakuli    "
},
{
	"uri": "/Docs/writing_tests/interact/",
	"title": "Interact",
	"tags": [],
	"description": "",
	"content": " Interacting with the environment In addition to screenshot-based test actions, Sakuli is capable of utilizing your keyboard, clipboard and environment variables. All these features are incorporated in the Environment class.\nKeyboard actions The following snippet shows a possible use-case for native keyboard actions. When initiating a download in Firefox, a native file download dialog opens. To start the download, we need to accept the file dialog, something that is not possible within the capabilities of Selenium. With Sakuli you get the opportunity to work around this problem, just like a real user would do. We can accept the file dialog by simply pressing the Enter button. Use Firefox as a browser for this test to work, as Chrome simply downloads the file without user interaction:\n(async () =\u0026gt; { const testCase = new TestCase(\u0026#34;test\u0026#34;); const url = \u0026#34;https://nodejs.org/en/\u0026#34;; const env = new Environment(); try { await _navigateTo(url); await _click(_link(\u0026#34;ABOUT\u0026#34;)); await _click(_link(\u0026#34;Releases\u0026#34;)); await _click(_link(\u0026#34;Dubnium\u0026#34;)); await _highlight(_link(/node-v10.\\d{1,}.\\d{1,}.tar.gz/)); await _click(_link(/node-v10.\\d{1,}.\\d{1,}.tar.gz/)); await _wait(3000); //wait for browser pop-up to activate  await env.keyDown(Key.ENTER); await env.keyUp(Key.ENTER); } catch (e) { await testCase.handleException(e); } finally { testCase.saveResult(); } })().then(done); It is even possible to change the download location dynamically in some environments, by entering a new save path via:\nawait env.type(\u0026#34;/new/path/to/file\u0026#34;); Secrets Many E2E tests require some kind of login. While there is no problem in general, it still requires some mechanism to handle credentials. Providing credentials via environment variable is a common practice, but it still is inconvenient when deploying the testcase to another system, since every single environment variable has to be migrated too.\nSakuli comes with a built-in mechanism to deal with sensitive data in testcases. It uses a single masterkey, generated by Sakuli itself, to de- or encrypt secrets used in testcases.\nRunning\nnpx sakuli create masterkey will generate a new masterkey, which should be exported as an environment variable SAKULI_ENCRYPTION_KEY.\nOnce the masterkey has been exported, secrets can be encrypted by running:\nnpx sakuli encrypt \u0026#34;super secret string\u0026#34; These encrypted secrets can now be stored safely inside your testfile. The Environment class provides methods to decrypt these secrets during test execution.\nawait env.typeAndDecrypt(\u0026#34;$ENCRYPTED_SECRET\u0026#34;); // alternatively, via clipboard await env.pasteAndDecrypt(\u0026#34;$ENCRYPTED_SECRET\u0026#34;); "
},
{
	"uri": "/Docs/start/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Installation Process The following steps are required to set up Sakuli to work with multiple browsers. Once the initial setup is done, we will dive right into our first test.\nWebDriver Installation Sakuli utilizes the WebDriver protocol to remote control browsers during test execution. In addition to the browser itself, you need to install the corresponding WebDriver as well. Several wrapper packages can be found on npmjs.com, which allow the installation of the required binaries via npm.\nSince some users encountered issues with geckodriver on Firefox, we recommend using chromedriver for now. We are working on fixes and workarounds for geckodriver.\nTherefore, Chrome is the preferred browser for running Sakuli tests at the moment. A suitable WebDriver can be installed via:\nnpm i chromedriver or\nyarn add chromedriver There are also WebDriver packages for IE and Edge. macOS already ships a WebDriver for Safari, so there is no need to install an additional package.\nAttention: Be careful to install the correct version of a WebDriver package according to the installed browser version. To install e.g. ChromeDriver for Chrome 73 you have to install:\nnpm i chromedriver@73.0.0 Sakuli is not limited to work with only a single browser. When installing multiple WebDriver packages, you can easily switch between different browsers.\nRegarding Windows Users: You will have to manually add the respective WebDriver location to your system PATH, otherwise Sakuli will not be able to find and use it. Once you installed a WebDriver package via NPM, you will be prompted with its installation path, so you can easily add it to your %PATH% variable.\nSample path: %USERPROFILE%\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\chromedriver\\\\lib\\\\chromedriver\\\\\nSakuli Installation 3rd-party dependencies One of Sakuli\u0026rsquo;s core components, nut.js, requires OpenCV. Sakuli ships a pre-built version of OpenCV. Nonetheless, the installation still requires some 3rd-party dependencies.\nWindows In order to install and run Sakuli on Windows you need two additional tools: Python 2 and the Windows Build Tools.\nTo avoid eventual installation problems for Windows users we recommend to first install Python 2 on your system separately by downloading the required version from the official web page. Afterwards you can install the Windows Build Tools manually or via NPM using:\nnpm install --global windows-build-tools or\nyarn global add windows-build-tools In case of errors while installing the Windows Build Tools package via npm, please make sure that the PowerShell is available on your system PATH. Additionally, you should install the Windows Build Tools by using the PowerShell in administrative mode.\nSee this issue for further reference.\nmacOS On macOS, Xcode command line tools are required. You can install them by running: xcode-select --install\nLinux Depending on your distribution, Linux setups may differ.\nIn general, Sakuli requires:\n Python 2 g++ make libXtst libPng  Installation on *buntu: sudo apt-get install build-essential python libxtst-dev libpng++-dev\nThe installation process is an open issue and will be improved in the near future, so using Sakuli will become even more enjoyable!\nSakuli Installation We will now install Sakuli in our newly created project by running:\nnpm i @sakuli/cli or\nyarn add @sakuli/cli This will install Sakuli and its required dependencies.\nReference  opencv4nodejs robotjs  "
},
{
	"uri": "/Docs/enterprise_features/e2e/",
	"title": "E2E Test Container",
	"tags": [],
	"description": "",
	"content": " E2E Test Container Lorem Ipsum.\n"
},
{
	"uri": "/Docs/writing_tests/screenshot/",
	"title": "Screenshot",
	"tags": [],
	"description": "",
	"content": " Screenshot based Testing A lot of E2E scenarios exceed the capabilities of browsers and webdrivers. This might include common use-cases like a drag and drop from the host system to a webpage or exporting a report into a spreadsheet or PDF-format. In these cases, your web-based tests can be extended to also validate behavior and invoke interactions outside the browser, all within a single test.\nOf course, you can also use Sakulis native testing power on its own, e.g. rich-client testing of SAP, office or proprietary software systems. Sakuli accomplishes its native capabilities by scanning the whole screen (or a dedicated region) on a stand-alone computer or in headless container screens, searching for provided image patterns.\nScreenshot based actions are relying on an abstract Region class, which represents an abstract region on the desktop. When creating a new instance without parameters, a Region spans over the whole desktop. But, it is also possible to create new regions by specifying left, top, width and height parameters.\nThe following example represents a test which drags a source element to a target region. In this demo scenario, both source and target are both located on screen via template image.\nTo reproduce this scenario, you need to capture screenshots of the egg and the pan.\n(async () =\u0026gt; { const testCase = new TestCase(\u0026#34;native_keyboard_demo\u0026#34;); const url = \u0026#34;https://codepen.io/naturalhanglider/full/jQMWoq\u0026#34;; const screen = new Region(); try { await _navigateTo(url); await screen .find(\u0026#34;source_egg.png\u0026#34;) .mouseMove() .dragAndDropTo( await screen.find(\u0026#34;target_pan.png\u0026#34;) ); await _wait(3000); } catch (e) { await testCase.handleException(e); } finally { testCase.saveResult(); } })().then(done);  -- Your browser does not support the video tag.   The dragAndDropTo(...) methods always move straight to the target region. In order to follow a more complex path, it is also possible to perform the drag gesture manually. Once the source image has been located on the screen, Sakuli moves the mouse to its location, presses and holds the left mouse button. Afterwards, it locates the target image, moves the mouse there while still holding the mouse button and releases it, once it reaches the target location.\nTo reproduce this scenario, you need to capture screenshots of the egg and the pan.\n(async () =\u0026gt; { const testCase = new TestCase(\u0026#34;native_demo\u0026#34;); const url = \u0026#34;https://codepen.io/naturalhanglider/full/jQMWoq\u0026#34;; const screen = new Region(); try { await _navigateTo(url); await screen.find(\u0026#34;source_egg.png\u0026#34;).mouseMove().mouseDown(MouseButton.LEFT); await new Region(0, 0, 10, 10).mouseMove(); await new Region(500, 700, 50, 100).mouseMove(); await screen.find(\u0026#34;target_pan.png\u0026#34;).mouseMove().mouseUp(MouseButton.LEFT); await _wait(3000); } catch (e) { await testCase.handleException(e); } finally { testCase.saveResult(); } })().then(done); "
},
{
	"uri": "/Docs/start/firsttest/",
	"title": "First Setup",
	"tags": [],
	"description": "",
	"content": " Setup Setup your first Test Since we wanted to keep Sakuli mostly compatible to v1, the file layout looks basically the same for testsuites.\nEach testsuite is located in its own particular folder. Generally, a testsuite represents the system you want to test. Therefore, you need to create that folder in your project root (where the package.json file is located):\nmkdir my-sut To describe the testsuite and its testcases, two additional files are needed: testsuite.properties and testsuite.suite. These files are required for backwards compatibility (they might not be necessary in the future but will at least be supported). These files should be added to the my-sut folder:\ncd my-sut echo \u0026gt; testsuite.suite echo \u0026gt; testsuite.properties We can add the following contents to testsuite.properties:\necho testsuite.id=my-sut \u0026gt; testsuite.properties This is the minimum configuration for using Sakuli. The .properties file adds some metadata needed by the Sakuli-Runtime and can be changed to configure other things like forwarders or the default browser for the execution.\nThe testsuite.suite file tells Sakuli which testcases are running. The format is:\n\u0026lt;FOLDER-NAME\u0026gt;/\u0026lt;FILE-NAME\u0026gt;.js \u0026lt;START_URL\u0026gt; The actual testcase file must be placed inside a folder (this is due to the format forced by Sahi in Sakuli v1). The start-url also needs to be added but has no effect in v2+.\nWith this in mind, we can add a testcase file:\nmkdir my-testcase echo \u0026gt; my-testcase/testcase.js And add the following information to the testsuite.suite file:\necho my-testcase/testcase.js https://sakuli.io \u0026gt; testsuite.suite After the setup you can add the actual testcode to my-testcase/testcase.js:\n(async () =\u0026gt; { // 1  const testCase = new TestCase(); // 2  try { // actual testcode goes here  } catch (e) { await testCase.handleException(e); // 3  } finally { await testCase.saveResult(); // 4  } })().then(done); // 5 Let us examine this piece of code:\n The whole test is wrapped in an async immediate invoked function. It allows us to use the async/await syntax of ES6. Since Sakuli makes heavy use of async operations, it makes your code more readable. To provide Sakuli information about our actual testcase, we create a TestCase object, which handles the execution of a testcase. If any error occurs during testing, it will be redirected to the TestCase object. It triggers Sakuli\u0026rsquo;s internal error handling e.g. taking a screenshot of the actual failed test execution. Regardless of a failed or passed test execution, Sakuli saves all results. This is more like a legacy artifact and will be removed in the future. When the async code within the main function (see 1.) is completed, a callback passed to the then function is invoked. done is a global function, which is injected by Sakuli and which tells the engine that the test execution is over (in theory you could call this function done() but the syntax above is recommended).  Write your first test Let us write a simple test using the Sakuli.io homepage as test subject. This test will verify if our \u0026ldquo;Getting Started\u0026rdquo; guide that you are reading at this very moment is still accessible.\n(async () =\u0026gt; { const testCase = new TestCase(); try { await _navigateTo(\u0026#34;https://sakuli.io\u0026#34;); // 1  testCase.endOfStep(\u0026#34;Open Landing Page\u0026#34;, 5, 10); // 2  await _click(_link(\u0026#34;Getting started\u0026#34;)); // 3  testCase.endOfStep(\u0026#34;Navigate to Getting Started\u0026#34;, 3, 5); await _highlight(_code(\u0026#34;npm init\u0026#34;)); // 4  testCase.endOfStep(\u0026#34;Find npm init code sample\u0026#34;); } catch (e) { await testCase.handleException(e); } finally { await testCase.saveResult(); } })().then(done);  Since we are dealing with a web test, the first thing we want to do is to _navigateTo our target page. Instead of manually setting up the correct WebDriver instance, we just have to provide a target URL. Sakuli will take care of the rest for us. await indicates that we are patiently waiting for our page to load before we continue with our next testing step. Once our initial page load has been completed, it is of our great interest to know how long it took to render. When it comes to runtime, Sakuli does not only measure the execution time of testcases, but also allows to split a single testcase into several logical steps. This way it becomes possible to accurately measure the runtime of certain processes like e.g. login, shopping cart, checkout and so on. By calling testCase.endOfStep(\u0026quot;Open Landing Page\u0026quot;, 5, 10);, we are ending our first step, the initial page load. Additionally, it is also possible to specify warning and critical thresholds for each step. Whenever a step exceeds one of these values, the result will change from OK to WARNING or CRITICAL. With Sakuli it becomes very easy to interact with web elements. In our current example, we want to _click a _link which is identified by some given text. Once again, we do not have to take care of many details, as Sakuli will do most of the heavy lifting for us. We are just passing the link text to Sakuli, which will search for our desired element using multiple identifiers. This way we do not have to worry about using an ID, a CSS selector or something else to identify our element. As we have already seen in our first test action, await will wait until the test action has been completed. In some cases, it is really helpful to visually verify test execution. Sakuli comes with a built-in _highlight function, which will highlight an element with a bright red border. Although being useful, _highlight should be used carefully since it will increase the overall testing runtime.  Execute your first test Since Sakuli 2 is built with Node, there are at least two different ways to execute a Sakuli test. We will take a look at each one of them. Organizing tests as NPM projects makes it easier for you to distribute testcode. Everything required to execute the test is described in a project config, so tests should be ready to use after running npm install inside a project. 👍\nnpx Because of the way we have set up and configured our project in this guide, Sakuli is only available to this particular project. npx is a really handy tool, which allows us to execute our Sakuli CLI directly from the command line, even though we did not add it to the system PATH.\nIn order to run our first test, we just have to execute npx sakuli run my-sut inside our project folder (e.g. /tmp/sakuli_starter on *nix). By default, Sakuli will pick up the browser configured in the testsuite.properties file, but with npx it is possible to change the browser on the fly: npx sakuli run my-sut --browser chrome This command will execute our test in Chrome.\nRegardless of the browser choice, as long as our site did not slow down, you should see a successful test result, similar to the image on the right. The advantage of running your tests with npx is the flexibility to easily customize your test runs without having to edit files.\n"
},
{
	"uri": "/Docs/start/temp/",
	"title": "Temp",
	"tags": [],
	"description": "",
	"content": " for code snippets use this template wrapper for the typescript color scheme (async () =\u0026gt; {})().then(done); // 5 example heading 1 (tallest) Example Text\n"
},
{
	"uri": "/Docs/enterprise_features/test/",
	"title": "Test",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum.\n"
},
{
	"uri": "/Docs/enterprise_features/test/test/",
	"title": "Test",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum. nico\n"
},
{
	"uri": "/Docs/writing_tests/webtests/",
	"title": "Webtests",
	"tags": [],
	"description": "",
	"content": " Web tests For DOM based testing most of the functions from Sahi tests can be used (please note that Sakuli only implements the open source APIs).\nThe main difference between Sakuli v1 and Sakuli v2 is the usage of Promises in the action API, meaning that you have to await a click for example.\nOn the other hand, element selectors remain synchronized functions but will not do the actual DOM fetching anymore. While an expression like var $e=_link('Sakuli') did an actual DOM-access in Sakuli v1.x, it returns a kind of abstract query for an element now. So, action can fetch this element whenever it is required.\nA detailed list of all available functions can be found in the Sahi API interface,\nAccessor API The Accessor API is described in the Accessor API interface.\nSakuli uses the concept of reusable Queries rather than directly working on an element-object (like in Selenium). Sakuli offers an expressive set of Accessors like _div, _textbox or _table. These accessors will not return an actual element or any reference to it. Rather it will create a SahiElementQuery. This query can then be used in various Actions like _click, _highlight or _isVisible. This concept could be compared with Locators in Selenium. This architecture gives us two nice benefits:\n Compatibility with Sahi API Since Sakuli handles the actual fetching and validation of an element by performing retries, refreshes, implicit wait etc. which reduce annoying issues with Selenium a lot (e.g. StaleElementReferenceError)  Most accessors are defined in the same way: They are functions that take an AccessorIdentifier as a first parameter and a variadic list of Relations:\n_NAME(identifier, ...relations): SahiElementQuery  The accessor adds a static Locator to the returned query. Since a query object consists of a locator, an identifier and a list of relations, we will eventually get an entire query object. The locator basically is a CSS element selector which you would expect from the accessor name - so _div for example adds By.css('div'), _textbox adds By.css('input[type=\u0026quot;text\u0026quot;], input:not([type])') and so on.\nElementQueries Since Sakuli encapsulates the creation (through accessors) and the application (e.g. through actions) of a SahiElementQuery, a user will rarely get in touch with these objects directly. Nevertheless, it is good to understand how Sakuli works with queries. Let us consider this example:\nawait _click(_button(\u0026#39;Sign In\u0026#39;));  The following will happen under the hood:\n _button creates a query with a locator to a button element and with 'Sign In' as an identifier and an empty list of relations\n This query is passed to the _click action. This action uses the AccessorUtil to fetch an element. It will:\n Fetch a list of all elements from the locator Reduce the list based on the relations (skipped when this list is empty) Reduce the list with the identifier logic Return the first entry of the remaining elements list   Identifier The identifer is another relict from Sahi that can be one of the following types:\n   Type Effect     number The identifier is considered as index. Sakuli picks the element at this index (zero-based) in step 2.3   RegExp Tests this RegExp against the following attributes of each element in the list at step 2.1: [aria-describedby], [name], [id], className, innerText, value, src   string The string is normalized and wrapped into a RegExp, therefore the same logic as for RegExp is applied   AccessorIdentifierAttributes This could be an object with the properties sahiIndex and/or sahiIndex, sahiText, className. The first two are handled like a number or a string identifer, respectively. The latter one works like a string identifier which only checks for the className property     Since we mostly apply the logic of Sahi comparisons against the class attribute are pretty dumb. While the attribute value is semantically a space separated list of class names. It is just handled as a usual string in Sahi (and therefore also in Sakuli so far).\n Action API The Action API is described in the Action Api interface.\nActions usually invoke a Selenium action sequence with an activated bridge mode to cover compatibility to most webdriver implementations. An action accepts a SahiElementQuery or a WebElement and tries to perform the action on this element several times. This approach reduces the count of StaleElementReferenceErrors dramatically, especially when a query is used.\n_eval Beside the fact that actions work asynchronously now, they behave like in Sahi. One exception is the _eval method, which accepts a string now containing some JavaScript code, which is performed on the website by the webdriver implementation (see executeAsyncScript method of Seleniums Thenablewebdriver).\nconst windowOuterHeight = await _eval(`return window.outerHeight`)  Fetch API The Fetch API is described in the Fetch API interface.\nThese methods are useful to get deeper access to elements and element-attributes:\nconst [x,y] = await _position(_image(\u0026#39;funny-cat-image.png\u0026#39;));  or let you perform checks (e.g. if an element exists).\nif(await _exists(_div(\u0026#39;cookie-banner\u0026#39;))) { await _click(_button(\u0026#39;I agree\u0026#39;)) }  Selenium Fallbacks Since Sakuli uses Seleniums webdriver it also provides various ways to access the functionality of this backend.\n It is recommended to use Sakulis built-in functionalities rather than work with the driver instances or any WebElement directly. At the moment, Sakuli is built upon Selenium. Nevertheless, a switch to other technologies in the future is possible. Downwards compatibility is only possible for Sakulis built-in functionalities. Direct use of webdriver instance methods is not supported.\n WebDriver instance Sakuli test scripts provide a globally accessible object of the current WebDriver instance which can be used to invoke its native methods directly. This might be useful for switching between frames:\nawait driver.switchTo().frame(1); await _click(_div(\u0026#39;element-in-frame-1\u0026#39;)); await driver.switchTo().defaultContent();  WebElement instances The Fetch API provides the _fetch function which returns the native WebElement instance from Seleniums webdriver for a query:\nconst webElement = await _fetch(_image(\u0026#39;funny-cat-image.png\u0026#39;)); const {width, height} = await webElement.getRect();  "
},
{
	"uri": "/Docs/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " The Pinnacle of Testing Behavior and performance validation of basically every application. Test like a real-world user!\n"
},
{
	"uri": "/Docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/Docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]