[
{
	"uri": "/docs/enterprise_features/icinga/",
	"title": "Icinga2 Forwarder",
	"tags": [],
	"description": "",
	"content": " icinga2 forwarder add the forwarder using the assistant or configure it manually:\nnpm i @sakuli/forwarder-icinga2 to register the forwarder into your project you have to edit the package.json file and add the preset to the sakuli configuration key:\n{ \u0026#34;sakuli\u0026#34;: { \u0026#34;presetprovider\u0026#34;: [ \u0026#34;@sakuli/legacy\u0026#34;, \u0026#34;@sakuli/forwarder-icinga2\u0026#34; ] } } installation of any enterprise feature requires a proper setup of your license information. you can find further information in the enterprise section.\nenable the icinga2 api all steps required to enable the icinga2 api are described in the rest api documentation.\ncreate a icinga2 service create a check_command which will only be executed if icinga2 did not receive a sakuli result within a certain time. this ensures that you get a notification even if no passive check result reaches icinga2 at all:\n/etc/icinga2/conf.d/commands.conf object checkcommand \u0026#34;check_dummy\u0026#34; { import \u0026#34;plugin-check-command\u0026#34; command = [ plugindir + \u0026#34;/check_dummy\u0026#34;,\u0026#34;$dummy_state$\u0026#34;,\u0026#34;$dummy_text$\u0026#34; ] vars.dummy_state = 0 vars.dummy_text = \u0026#34;check was successful.\u0026#34; } object checkcommand \u0026#34;check_sakuli\u0026#34; { import \u0026#34;check_dummy\u0026#34; vars.dummy_state = 3 vars.dummy_text = \u0026#34;no passive sakuli check result received.\u0026#34; }\n/etc/icinga2/conf.d/hosts.conf object host \u0026#34;sakuliclient01\u0026#34; { import \u0026#34;generic-host\u0026#34; address = \u0026#34;\u0026lt;ip\u0026gt;\u0026#34; }\ncreate the following service object for the first testcase. the freshness_threshold should be slightly higher than the interval sakuli tests are planned.\nobject service \u0026#34;sakuli_demo\u0026#34; { import \u0026#34;generic-service\u0026#34; host_name = \u0026#34;sakuliclient01\u0026#34; check_command = \u0026#34;check_sakuli\u0026#34; enable_active_checks = 0 enable_passive_checks = 1 enable_flapping = 0 volatile = 1 enable_perfdata = 1 } reload icinga2:\nservice icinga2 reload after opening icingaweb2 you should see the sakuli host with the service \u0026ldquo;sakuli_demo\u0026rdquo; attached.\nthe check is waiting now for check results from a sakuli client.\nsakuli client configuration you must set the global properties for the icinga2 receiver on the sakuli client by editing the sakuli.properties. you can find them in the folder containing the testsuites:\n   property default effect     sakuli.forwarder.icinga2.enabled false enables result forwarding to icinga2   sakuli.forwarder.icinga2.api.host  the hostname or ip of the icinga2 api-endpoints   sakuli.forwarder.icinga2.api.port 5665 the port or ip of the icinga2 api-endpoints   sakuli.forwarder.icinga2.api.username  api user name   sakuli.forwarder.icinga2.api.password  api user password   sakuli.forwarder.icinga2.hostname  the name of the host object configured in icinga2   sakuli.forwarder.icinga2.service_description ${testsuite.id} the name of the service in icinga2   sakuli.forwarder.icinga2.allow_insecure_connection false disable ssl checks. never use this in production environments!    "
},
{
	"uri": "/docs/getting-started/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": " what you need sakuli is built and tested against the current lts version of node.js.\nup to version 2.2.0 sakuli supports node v10.x (lts/dubnium). starting with version 2.3.0, sakuli also supports v12.x (lts/erbium). in order to be able to run sakuli on your system, we will assume that you have a working node installation.\nto install node on your system, you can either go to the node website or you can use tools like node version manager utility to manage various node versions on a per-user basis. in general, a per-user installation is the preferred way since it runs in an unprivileged mode.\nattention there\u0026rsquo;s an issue regarding sakuli in combination with node versions \u0026gt;= 12.13.1 on macos (see #2398 and #31623) which causes sakuli tests to break when using native actions like env.type(...).\nif you happen to run into this issue, please try downgrading to node v12.13.0 to run your tests.\n"
},
{
	"uri": "/docs/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " easy start the following video shows a quick introduction on how to install and bootstrap sakuli and how to setup and start your first ui-test on a mac computer. for a detailed installation procedure, please click the green arrow to the right or navigate through the table of content on the left navigation pane.\nyour browser does not support the video tag.   steps to reproduce easy start prerequisite is a node v12 (lts/erbium) installation on your mac.\nnpm init accept all questions with enter key.\nnpm i @sakuli/cli npm i chromedriver npx sakuli create project . my-demo open the file check.jsand insert the following test-script:\n(async () =\u0026gt; { const testcase = new testcase(); try { await _navigateto(\u0026#34;https://sakuli.io\u0026#34;); testcase.endofstep(\u0026#34;open landing page\u0026#34;, 5, 10); await _click(_link(\u0026#34;getting started\u0026#34;)); await _click(_link(\u0026#34;initialization\u0026#34;)); testcase.endofstep(\u0026#34;navigate to initialization section\u0026#34;, 3, 5); await _highlight(_code(\u0026#34;npm init\u0026#34;)); testcase.endofstep(\u0026#34;find npm init code sample\u0026#34;); } catch (e) { await testcase.handleexception(e); } finally { await testcase.saveresult(); } })(); npx sakuli run my-demo "
},
{
	"uri": "/docs/enterprise_features/check/",
	"title": "checkmk Fowarder",
	"tags": [],
	"description": "",
	"content": " checkmk forwarder add the forwarder using the assistant or configure it manually:\nadd the forwarder to your project with:\nnpm i @sakuli/forwarder-checkmk to register the forwarder into your project you have to edit the package.json file and add the preset to the sakuli configuration key:\n{ \u0026#34;sakuli\u0026#34;: { \u0026#34;presetprovider\u0026#34;: [ \u0026#34;@sakuli/legacy\u0026#34;, \u0026#34;@sakuli/forwarder-checkmk\u0026#34; ] } } installation of any enterprise feature requires a proper setup of your license information. you can find further information in the enterprise section.\nsakuli client configuration it is assumed that the client is already monitored by checkmk and that an agent is installed and running on it.\nspool folder create a new folder spool in the installation path of the checkmk agent. this is the folder where the results will be written and stored into. don\u0026rsquo;t forget to grant writing permissions for the folder to the user running sakuli checks.\nforwarder configuration now you have to set up the properties for the checkmk receiver. in order to do this, edit the sakuli.properties in the folder containing the testsuites:\n   property default effect     sakuli.forwarder.check_mk.enabled false enables writing to the spool file   sakuli.forwarder.check_mk.spooldir /var/lib/check_mk_agent/spool (linux)\u0026lt;cmk_installation_path\u0026gt;\\\\spool (windows) path to the spool folder as defined above. on windows, the backslashes have to be escaped with \u0026lsquo;\\\u0026lsquo;. check_mk is expecting the result files from sakuli in here   sakuli.forwarder.check_mk.freshness 600 defines the maximal age in seconds for which the result is still valid. if the last modification of the result file is older than this property, the result file will be ignored. the check_mk service will turn into unknown   sakuli.forwarder.check_mk.spoolfile_prefix sakuli_suite_ defines the result file prefix. it can be used to change the default naming convention for the check_mk output files   sakuli.forwarder.check_mk.service_description ${testsuite.id} defines the service description which is used within the check result   sakuli.forwarder.check_mk.piggyback_hostname local defines hostname for check results, configurable for piggyback results   sakuli.forwarder.check_mk.output.details true dis- / enables detailed html output   sakuli.forwarder.check_mk.section_name local name of the reported section (\u0026lt;\u0026lt;\u0026lt;your_section_name\u0026gt;\u0026gt;\u0026gt;)   sakuli.forwarder.check_mk.url.enabled false adds the url specified in sakuli.forwarder.check_mk.url to the spool file (available from version 2.3.0)   sakuli.forwarder.check_mk.url  url address to add to the spool file (available from version 2.3.0)    an example configuration could look like this:\nsakuli.forwarder.check_mk.enabled=true sakuli.forwarder.check_mk.spooldir=/var/lib/check_mk_agent/spool sakuli.forwarder.check_mk.freshness=600 sakuli.forwarder.check_mk.spoolfile_prefix=sakuli_suite_ sakuli.forwarder.check_mk.service_description=my_custom_service sakuli.forwarder.check_mk.piggyback_hostname=myhost "
},
{
	"uri": "/docs/writing_tests/anatomy/",
	"title": "Anatomy",
	"tags": [],
	"description": "",
	"content": " anatomy of a project this guide assumes that you have finished the \u0026ldquo;getting started\u0026rdquo; tutorial or that you are experienced with sakuli v1.\n most of the complexity and conventions are due to the backwards compatibility to v1, which requires a specific folder and file structure for various reasons (the biggest is sahi). sakuli offers now various ways to reduce this complexity dramatically. these features will eventually become part of upcoming releases.\n setup and configuration the minimum setup for a sakuli project looks like this:\n  your-sakuli-project home folder of the project   package.json all dependencies and setups for node.js  sakuli.properties (optional: configuration for all testsuites)  testsuite-a home folder of a testsuite   testsuite.suite defines which testcases belong to the testsuite  testsuite.properties configuration for the testsuite (overrides configuration from \u0026lsquo;../sakuli.properties\u0026rsquo;)  testcase home of the testcase   testcase.js the actual testcase     this file layout also represents the logical structure of sakuli, which consists of a testsuite with one or more testcase(s). sakuli\u0026rsquo;s run command takes the path to a testsuite folder and runs all testcases defined in testsuite.suite of the given folder.\ntestsuite.suite this file is a relic from sahi where you define testcases and their respective start-urls. it has a simple format:\n\u0026lt;case-path\u0026gt;/\u0026lt;case-file\u0026gt; \u0026lt;start-url\u0026gt;  \u0026lt;case-path\u0026gt; is a path within the testsuite file, which has to contain the file \u0026lt;case_file\u0026gt;. the \u0026lt;start-url\u0026gt; is no longer used by sakuli (but required to fulfil the file format). the format also supports comments (// at the beginning of a line). testcases can be activated or deactivated by using comments.\n the configured start-url is omitted to force test authors to write explicit navigation to the url for testcases using _navigateto.\n properties files each testsuite requires a testsuite.properties file with at least one entry:\ntestsuite.id=somename  it \u0026ldquo;inherits\u0026rdquo; its values from ../sakuli.properties (which also means that the same property from sakuli.properties becomes overridden).\n property files are a common way to store configuration in java, the former runtime for sakuli. it is a simple key-value format (\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;) where every line defines a key-value pair. to organize the keys, it is a common - but not required - practice to separate names by dots (similar to java namespaces).\n there are several predefined properties that can be configured to influence the behavior of sakuli (* indicates a required property):\n   property type: default comment / example     testsuite.id string*: / name of the suite shown in the output and used by the forwarder   testsuite.browser string: \u0026lsquo;firefox\u0026rsquo; browser which is started by the webdriver (it can be overridden by the --browser command line argument)    you can also define own properties and use them in your testcases. just put your custom property key with the corresponding value in one of the .property files and into your testcase. you can retrieve the values with help of the environment class:\n// omitting boilerplate // assuming you have added // user.name=tester // in one of the property files const env = new environment(); await _setvalue(_textbox(\u0026#39;username\u0026#39;), env.getproperty(\u0026#39;user.name\u0026#39;));  "
},
{
	"uri": "/docs/getting-started/initialization/",
	"title": "Initialization",
	"tags": [],
	"description": "",
	"content": " initialize a project this guide will get you started with writing sakuli tests from scratch. to follow this tutorial, you should create a new npm project in an empty folder.\nfor this guide, we will assume that our working directory is /tmp/sakuli_starter on a *nix system, or %temp%\\sakuli_starter on a windows machine.\nto create a new, empty project, first run:\nnpm init this interactive prompt will ask you for some metadata regarding your project. you can either modify these fields to your needs or just accept the defaults.\nonce completed, you should see a short summary similar to the following snippet:\nabout to write to /tmp/sakuli_starter/package.json: { \u0026#34;name\u0026#34;: \u0026#34;sakuli_starter\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;isc\u0026#34; } is this ok? (yes) the empty project has been initialized after confirming the prompt.\n"
},
{
	"uri": "/docs/writing_tests/",
	"title": "Writing Tests",
	"tags": [],
	"description": "",
	"content": " how to write tests with sakuli v2+ we changed a lot under the hood and completely replaced the technology-stack. this resulted in a more flexible and future-ready architecture while preserving a maximum of backward compatibility.\nmajor changes to sakuli v1 (migration) nearly all functions and classes from sakuli v1 are available in sakuli v2+. they are provided by the @sakuli/legacy package.\nasync / await you might have wondered where the await keyword came from when you saw the sakuli v2+ code. this resulted from the decision to use node.js as the new runtime for sakuli. the following section will describe the background of the async/await syntax and its use in sakuli. if you are already familiar with javascript, you can skip this section since it contains a lot of basic information.\nwhy we need it tl; dr;\n due to the runtime and core libraries, asynchronous operations are required (and cannot be turned into synchronous operations) async/await is the most idiomatic way to handle asynchronous code in javascript  if you ever worked with sakuli and followed our \u0026ldquo;getting started\u0026rdquo; guide, you might have noticed one of the most obvious paradigmatic changes regarding the test syntax: the wrapping (async () =\u0026gt; /*...*/)(); and the extensive use of await. this is due to the new runtime node.js and its asynchronous nature. node.js executes scripts in a single-thread and therefore makes heavy use of asynchronous operations avoiding to block the execution within the thread. the underlying javascript engine is v8 (which also powers the javascript execution in chromium browsers). to make this asynchronous behavior possible, v8 uses a so called \u0026ldquo;event-loop\u0026rdquo; with a \u0026ldquo;call-stack\u0026rdquo; containing all deferred operations (like: reading a file, making a web-request, doing heavy computation and so on). this talk explains this behavior in a short and entertaining way. a good illustration for the event loop is a (fast-food) restaurant, where you place an order at the counter and get a receiver that informs you when your food is ready. now you can do something else in the meantime while not blocking other processes or being blocked by them until you get your food and can do further operations (e.g. eat your meal).\nbut how does all this effect sakuli? sakuli v1 was running within a java virtual machine and the test scripts were executed within the v8 (javascript runtime for the jvm) - its fundamental treatment of asynchronous operations completely differs compared to node. simply said, everything in java is blocking until you make it non-blocking, while in node (many) operations are non-blocking by default. in java for example it is a rather common custom to run while-loops until the asynchronous operation sets its condition to false. this repl displays the basic idea: v8.\n\u0026ldquo;unfortunately\u0026rdquo;, it is not (easily) possible to turn non-blocking operations into blocking operations in node (have a look at this repl) and sakuli\u0026rsquo;s core technologies (selenium-webdriver and nut.js) make heavy use of asynchronous operations. there are tools like fibers that can help you, but they rely on native (os-dependent) libraries. therefore, we have decided to avoid another os specific library in sakuli.\nlast but not least: using and writing asynchronous code is the most idiomatic way to write javascript nowadays. using async/await is a kind of syntactic sugar, which lets us write asynchronous code like it would be synchronous just by using the await keyword. a short look back in the old days makes it clear how javascript landed there:\nback then, the most common way to handle asynchronous code was via callbacks. they were passed on to the asynchronous operation where they were executed as soon as the initial operation was finished. this approach was useful and acceptable for the usual javascript use-case during those days: handling events in the dom. but when node was released and many browser applications became more and more complex, the developers ended up with a so called callback hell. to exit this callback hell, es6 introduced the promise class. the advantage of a promise is its ability to chain with other promises, making it way more elegant to write subsequent, dependent asynchronous operations. a good read on this topic can be found on chapter viii of javascript for impatient programmers\nthe async wrapper you might have noticed that if a testcase in sakuli v2 is wrapped within (async () =\u0026gt; /*...*/)().then(done) this construct it is called immediately invoked function expression (iife). basically, it is the definition of a function that is immediately invoked. this pattern is widely used in javascript to preserve scopes and namespaces, since every symbol, which is defined at the top level of a script, becomes part of the global namespace and may potentially collide with other scripts. in the era of web bundler and es-modules this use-case became more and more irrelevant. iife on the other hand still remains important after the introduction of async/await in javascript. one caveat of this syntax is, that the await keyword is only available within an asynchronous function - because the engine will wrap the whole body of this function within a promise. that means, that in order to be able to make use of the await keyword, your code has to be executed within an asynchronous function. on the top level iife, we declare the actual function as async and can make use of await. since the result of this function is automatically turned into a promise, we can invoke then and pass the done function to it. done is a sakuli specific function, which indicates to sakuli that the testcase script is finished. there is currently a discussion on the javascript proposal in stage 3, which would introduce a top level await in javascript.\nif you want to avoid this construct completely, you can use the then function of a promise. the example code of the getting started guide would look like this then:\nconst testcase = new testcase(); _navigateto(\u0026#34;https://sakuli.io\u0026#34;) .then(_ =\u0026gt; testcase.endofstep(\u0026#34;open landing page\u0026#34;, 5, 10)) .then(_ =\u0026gt; _click(_link(\u0026#34;getting started\u0026#34;))) .then(_ =\u0026gt; _click(_link(\u0026#34;initialization\u0026#34;))) .then(_ =\u0026gt; _highlight(_code(\u0026#34;npm init\u0026#34;))) .then(_ =\u0026gt; testcase.endofstep(\u0026#34;find npm init code sample\u0026#34;)) .catch(e =\u0026gt; testcase.handleexception(e)) .then(_ =\u0026gt; testcase.saveresult()) .then(done); this is also a totally valid format that can be used within sakuli. however, this approach has two downsides:\n if you are less familiar with javascript, it could become harder to read and understand the examples mentioned in the sakuli documentation will mostly use the await/async syntax  due to those reasons, we would advise you not to use the .then(...) syntax, unless you are completely sure about what you are doing.\nasync functions most functions which implement the sahi dsl - recognizable by a prefixed underscore - return a promise. that means, that you should put an await in front of it. exceptions from this pattern are accessor functions, which create query objects to access elements in the dom. you can check if the function returns a promise in the api docs of sahiapi. if you are not sure that you need an await, you can put it anyway since the function will be executed as expected. considering that this is not a good practice, we are working on tools which will help you identify async functions like typescript support.\nthenable classes sakuli has some classes - especially those for native interactions - which implement the fluent interface pattern, where you can chain method invocations on the same object. unfortunately, this does not really play nice with asynchronous operations. methods of a fluent api always return the object itself or at least an instance of the same class. but an asynchronous (and awaitable) method rather needs to return a promise. to still accomplish the goal of backward compatibility, all classes implementing a fluent interface and including asynchronous methods are wrapped in a thenable\u0026lt;classname\u0026gt; form of itself. this concept is highly inspired by selenium-webdrivers thenablewebdriver. from an end-user perspective, you can use the fluent interface almost like before, except of a little await at the beginning:\n// with thenable classes; assuming we are in the context of an async function await screen.find(\u0026#39;button.png\u0026#39;).click(); // without thenable class screen.find(\u0026#39;button.png\u0026#39;) .then(screen =\u0026gt; screen.click()); thenable classes are:\n application environment region  the technical trick behind this is, that there are two implementations: the actual class with the async functions and a thenable class, which implements the promiselike interface. the promiselike interface basically forces a then function to be implemented and is therefore \u0026ldquo;awaitable\u0026rdquo;. the wrapper class also holds a promise with the instance to the actual class. when a method of the thenable class is invoked, it delegates the call to the same method of the actual class and returns itself with the promise given back by the actual method. since the thenable class itself is a promise, it will resolve to an instance of the actual class.\n_include and _includedynamic if you ever wrote larger or different testcases on the same system, you might have come up with a modularization of commonly used functions. for example, the login to a system is always the same in all testcases, so you put it into a separate file.\nsakuli v1 includes functions to load these files into your actual testcase: _include or _includedynamic. the code usually looks like this:\n\u0026lt;testsuite\u0026gt;/common/login.js: function login($user, $password) { //... login logic }\n\u0026lt;testsuite\u0026gt;/testcase/case.js _include(\u0026#39;../commons/login.js\u0026#39;); try { var testcase = new testcase(\u0026#39;\u0026#39;); login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); // actual test code } catch(e) { testcase.handleexception(e); } finally { testcase.saveresults(); }\ntwo interesting aspects can be observed here:\n functions defined in the included script were added to the global namespace it is not an idiomatic way to require dependent code in javascript (nowadays)  sakuli now introduces support for es-module syntax. to adapt the example above, it has to be rewritten as follows:\n \u0026lt;testsuite\u0026gt;/common/login.js export async function login($user, $password) { //... login logic }\n \u0026lt;testsuite\u0026gt;/testcase/case.js import {login} from \u0026#39;./../commons/login\u0026#39;; try { var testcase = new testcase(\u0026#39;\u0026#39;); await login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); // actual test code } catch(e) { testcase.handleexception(e); } finally { testcase.saveresults(); }\nbeside the added async/await keywords, we can see that the first line of each script changed. in the first script, all functions (or classes, enums, constants, etc) have to be explicitly exported by the script (\u0026ldquo;module\u0026rdquo; would be a more accurate term) if they should be used in other scripts. for the actual testcase script the _include function will be removed and replaced by an import. the import ensures that we only import symbols that are required in the current script and its global namespace. each function required in the testcase script has to be imported explicitly. an alternative syntax is to import everything within its own namespace:\nimport * as loginutils from \u0026#39;./../commons/login\u0026#39;; // omitting boilerplate code  await loginutils.login(\u0026#39;user\u0026#39;, \u0026#39;password\u0026#39;); "
},
{
	"uri": "/docs/configuring_tests/",
	"title": "Configuring Tests",
	"tags": [],
	"description": "",
	"content": " sakuli properties sakuli tests can be fine-tuned via various properties.\nproject properties    property type: default comment / example     testsuite.id string*: / name of the suite shown in the output and used by the forwarder   testsuite.name string*: ${testsuite.id} descriptive name for the current test suite   testsuite.browser string: firefox browser which is started by the webdriver (it can be overridden by the --browser command line argument)   testsuite.warningtime number: 0 the warning runtime threshold (seconds) for suite execution. if the warning time is exceeded, the test suite will get the state \u0026lsquo;warning\u0026rsquo;   testsuite.criticaltime number: 0 the critical runtime threshold (seconds) for suite execution. if the critical time is exceeded, the test suite will get the state \u0026lsquo;critical\u0026rsquo;   testsuite.uionly boolean: false configure whether a testsuite should run in ui-only mode or not. if true, no browser will be started   sakuli.environment.similarity.default number: 0.99 configures the minimum requires similarity for image based matching. values in range 0 \u0026lt;= x \u0026lt;= 1   sakuli.typedelay number: 300 specifies the amount of time in ms to wait between keypresses   sakuli.encryption.key string: / master key for en- and decryption   sakuli.log.folder string: ${project.rootdir}/_logs folder for log files   sakuli.screenshot.onerror boolean: true enable / disable screenshots on error   sakuli.screenshot.dir string: ${project.rootdir}/_logs/_screenshots folder for screenshot files (if activated)    chrome properties    property type: default comment / example     selenium.chrome.arguments string*: / space separated list of chrome arguments, e.g. \u0026ndash;arg1 arg2 \u0026ndash;arg3=value arg4=value   selenium.chrome.headless boolean: false enable / disable headless mode   selenium.chrome.windowsize.width number: / browser window width   selenium.chrome.windowsize.height number: / browser window height   selenium.chrome.excludeswitches string*: / space separated list of chrome command line switches to exclude that chromedriver by default passes when starting chrome. do not prefix switches with \u0026lsquo;\u0026ndash;\u0026rsquo;   selenium.chrome.extensions string*: / comma separated list of extensions to install when launching chrome. each extension should be specified as the path to the packed crx file   selenium.chrome.binarypath string: / sets the path to the chrome binary to use    firefox properties    property type: default comment / example     selenium.firefox.profile string: / sets the profile to use. the profile may be specified as the path to an existing firefox profile to use as a template   selenium.firefox.binary string: / sets the binary to use. the binary may be specified as the path to a firefox executable    selenium.firefox.proxy string: / sets the proxy settings for the new session   selenium.firefox.usegeckodriver boolean: false boolean flag whether to use geckodriver or not    edge properties    property type: default comment / example     selenium.edge.proxy string: / sets the proxy settings for the new session   selenium.edge.pageloadstrategy string: \u0026lsquo;normal\u0026rsquo; sets the page load strategy for edge. supported values are \u0026lsquo;normal\u0026rsquo;, \u0026lsquo;eager\u0026rsquo; and \u0026lsquo;none\u0026rsquo;    internetexplorer properties    property type: default comment / example     selenium.ie.introduceflakinessbyignoringprotectedmodesettings boolean: false whether to disable the protected mode settings or not   selenium.ie.ignorezoomsetting boolean: false indicates whether to skip the check that the browser\u0026rsquo;s zoom level is set to 100%   selenium.ie.initialbrowserurl string: / sets the initial url loaded when ie starts. setting this option may cause browser instability   selenium.ie.enablepersistenthover boolean: true flag which configures whether to enable persistent mouse hovering (true by default)   selenium.ie.enableelementcachecleanup boolean: true flag which configures whether the driver should attempt to remove obsolete webelements from its internal cache on page navigation (true by default). disabling this option will cause the driver to run with a larger memory footprint   selenium.ie.requirewindowfocus boolean: false flag which configures whether to require the ie window to have input focus before performing any user interactions (i.e. mouse or keyboard events). this option is disabled by default, but delivers much more accurate interaction events when enabled   selenium.ie.browserattachtimeout number: 0 configures the timeout, in milliseconds, that the driver will attempt to located and attach to a newly opened instance of internet explorer. the default is zero, which indicates waiting indefinitely   selenium.ie.forcecreateprocessapi boolean: false flag which configures whether to launch internet explorer using the createprocess api. if this option is not specified, ie is launched using ielaunchurl, if available. for ie 8 and above, this option requires the tabprocgrowth registry value to be set to 0.   selenium.ie.arguments string*: / space separated list of command-line switches to use when launching internet explorer   selenium.ie.useperprocessproxy boolean: / flag which configures whether proxies should be configured on a per-process basis. if not set, setting a proxy will configure the system proxy. the default behavior is to use the system proxy   selenium.ie.ensurecleansession boolean: false flag which configures whether to clear the cache, cookies, history, and saved form data before starting the browser. using this capability will clear session data for all running instances of internet explorer, including those started manually   selenium.ie.logfile string: / sets the path to the log file the driver should log to   selenium.ie.loglevel string: / sets the iedriverserver\u0026rsquo;s logging level   selenium.ie.host string: / sets the ip address of the driver\u0026rsquo;s host adapter   selenium.ie.extractpath string: / sets the path of the temporary data directory to use   selenium.ie.silent boolean: false sets whether the driver should start in silent mode   selenium.ie.proxy string: / sets the proxy settings for the new session    selenium properties    property type: default comment / example     selenium.proxy string: / configuration parameters for using proxies in webdriver   selenium.httpagent string: / sets the http agent to use for each request   selenium.server string: / sets the url of a remote webdriver server to use. once a remote url has been specified, the builder direct all new clients to that server    "
},
{
	"uri": "/docs/enterprise_features/omd/",
	"title": "OMD Forwarder",
	"tags": [],
	"description": "",
	"content": " omd / gearman forwarder add the forwarder using the assistant or configure it manually:\nnpm i @sakuli/forwarder-gearman to register the forwarder into your project you have to edit the package.json file and add the preset to the sakuli configuration key:\n{ \u0026#34;sakuli\u0026#34;: { \u0026#34;presetprovider\u0026#34;: [ \u0026#34;@sakuli/legacy\u0026#34;, \u0026#34;@sakuli/forwarder-gearman\u0026#34; ] } } installation of any enterprise feature requires a proper setup of your license information. you can find further information in the enterprise section.\nconfigure omd sakuli transmits performance data to a gearman result queue rather than to omd directly. for that we require a gearman-enabled monitoring system in an omd environment.\nit takes a few steps to set up the monitoring system in order to process sakuli\u0026rsquo;s performance data correctly.\nenable and configure mod-gearman use the makefile located in omd_root/share/sakuli/omd/ to configure mod-gearman:\n enable all services for mod-gearman set the bind ip and port (default: 0.0.0.0:4730; overwrite with e.g. export gearman_port=192.168.130.10:4731) set the encryption key (default: sakuli_secret; overwrite with e.g. export gearman_secret=mykey)  then run:\nsu - \u0026lt;site_user\u0026gt; cd ~/share/sakuli/setup/omd make gearman due to security reasons, the makefile will only configure mod-gearman if it is not enabled yet. if it is already enabled inspect the makefile, read the instruction carefully and execute the steps by hand.\nfor production usage please use individual encryption keys!\nif you do not want to use encryption at all, enable accept_clear_results and disable sakuli.forwarder.gearman.encryption:\nvim ~/etc/mod-gearman/server.cfg ... accept_clear_results=yes testsuite.properties sakuli.forwarder.gearman.encryption=false\ngearman proxy (optional) use the sakuli gearman proxy script if you want to intervene between the communication of sakuli and naemon/nagios.\npossible use cases:\n changes parts of the messages sakuli sends to the monitoring system ⇒ there are some examples contained already getting notified when sakuli sends results to services that do not exist auto-create services for incoming results (not yet implemented)  use the makefile located in $omd_root/share/sakuli/ to enable the feature:\nsu - \u0026lt;site_user\u0026gt; cd n/share/sakuli/setup/omd make gearman_proxy edit etc/mod-gearman/sakuli_gearman_proxy.cfg :\n$remotehost=\u0026#34;172.17.0.2\u0026#34;; #1 $remoteport=\u0026#34;4730\u0026#34;; #1 $localhost=\u0026#34;172.17.0.2\u0026#34;; #2 $localport=\u0026#34;4730\u0026#34;; #2 $queues = { \u0026#34;$remotehost:$remoteport/check_results_sakuli\u0026#34; =\u0026gt; \u0026#34;$localhost:$localport/check_results\u0026#34;, }; #3 + 4 $err_h = \u0026#39;error_host\u0026#39;; #5 $err_s = \u0026#39;eror_svc\u0026#39;; $err_r = \u0026#39;2\u0026#39;; #6  gearman ip/port listening for sakuli results. set this to the same values as  unless gearman_proxy.pl is running on another system gearman ip/port for the monitoring system check_results_sakuli ⇒ queue name to receive sakuli results. make sure this queue name is defined in property sakuli.forwarder.gearman.server.queue on all sakuli clients (see sakuli client configuration) check_results ⇒ default queue of mod-gearman where gearman workers write back their results (no need to change that) the proxy does a live status query for each incoming package to ensure that the receiving host/service exists. it provides a special \u0026ldquo;error host/service\u0026rdquo; pair where the proxy can send a message in case of results coming back for non-existent services status of the messages for non-existent services (2 = critical)  su - \u0026lt;site_user\u0026gt; omd start sakuli_gearman_proxy # starting sakuli_gearman_proxy...ok check that the queue check_results_sakuli is running in addition to the default queue check_results.\nomd[demo]:~$ gearman_top 2017-06-09 13:37:28 - localhost:4730 - v0.33 queue name | worker available | jobs waiting | jobs running ----------------------------------------------------------------------- check_results | 1 | 0 | 0 check_results_sakuli | 1 | 0 | 0 ----------------------------------------------------------------------- this change does affect other monitoring checks executed with mod-gearman, because only sakuli will send results into the queue check_results_sakuli.\ncreate a nagios service create a service which should receive sakuli test results. host/service names derive from the following properties:\n host: sakuli.forwarder.gearman.nagios.hostname (defined globally or via suite) service: testsuite.id (defined in testsuite.properties)  omd configuration:\ndefine host { host_name sakuli_client alias sakuli_client address __sakuli_client_ip__ use generic-host } define service { service_description example_xfce host_name sakuli_client use tpl_s_sakuli_gearman freshness_threshold 180 }  the freshness_threshold should be slightly higher than the interval during which sakuli tests are executed.\n the check is waiting now for check results from a sakuli client.\nsakuli configuration you must set the global properties for the gearman receiver on the sakuli client. for doing this, edit sakuli.properties in the folder containing the testsuites:\n   property default effect     sakuli.forwarder.gearman.enabled false enable forwarding to omd   sakuli.forwarder.gearman.encryption true enable encryption and set the key only if you did not activate accept_clear_results in mod-gearman. otherwise, set encryption to false   sakuli.forwarder.gearman.secret.key secret-password the password configured in enable and configure mod-gearman   sakuli.forwarder.gearman.server.host  the host where omd is running   sakuli.forwarder.gearman.server.port 4730 the port where gearman is listing (configured in enable and configure mod-gearman)   sakuli.forwarder.gearman.server.queue check_results the default queue for sakuli    "
},
{
	"uri": "/docs/writing_tests/interact/",
	"title": "Interact",
	"tags": [],
	"description": "",
	"content": " interacting with the environment in addition to screenshot-based test actions, sakuli is capable of utilizing your keyboard, clipboard and environment variables. all these features are incorporated in the environment class.\nkeyboard actions the following snippet shows a possible use-case for native keyboard actions. when initiating a download in firefox, a native file download dialog opens. to start the download, we need to accept the file dialog, something that is not possible within the capabilities of selenium. with sakuli you get the opportunity to work around this problem, just like a real user would do. we can accept the file dialog by simply pressing the enter button. use firefox as a browser for this test to work, as chrome simply downloads the file without user interaction:\n(async () =\u0026gt; { const testcase = new testcase(\u0026#34;test\u0026#34;); const url = \u0026#34;https://nodejs.org/en/\u0026#34;; const env = new environment(); try { await _navigateto(url); await _click(_link(\u0026#34;about\u0026#34;)); await _click(_link(\u0026#34;releases\u0026#34;)); await _click(_link(\u0026#34;dubnium\u0026#34;)); await _highlight(_link(/node-v10.\\d{1,}.\\d{1,}.tar.gz/)); await _click(_link(/node-v10.\\d{1,}.\\d{1,}.tar.gz/)); await _wait(3000); //wait for browser pop-up to activate  await env.keydown(key.enter); await env.keyup(key.enter); } catch (e) { await testcase.handleexception(e); } finally { testcase.saveresult(); } })(); it is even possible to change the download location dynamically in some environments, by entering a new save path via:\nawait env.type(\u0026#34;/new/path/to/file\u0026#34;); secrets many e2e tests require some kind of login. while there is no problem in general, it still requires some mechanism to handle credentials. providing credentials via environment variable is a common practice, but it still is inconvenient when deploying the testcase to another system, since every single environment variable has to be migrated too.\nsakuli comes with a built-in mechanism to deal with sensitive data in testcases. it uses a single masterkey, generated by sakuli itself, to de- or encrypt secrets used in testcases.\nrunning\nnpx sakuli create masterkey will generate a new masterkey, which should be exported as an environment variable sakuli_encryption_key.\nonce the masterkey has been exported, secrets can be encrypted by running:\nnpx sakuli encrypt \u0026#34;super secret string\u0026#34; these encrypted secrets can now be stored safely inside your testfile. the environment class provides methods to decrypt these secrets during test execution.\nawait env.typeanddecrypt(\u0026#34;$encrypted_secret\u0026#34;); // alternatively, via clipboard await env.pasteanddecrypt(\u0026#34;$encrypted_secret\u0026#34;); "
},
{
	"uri": "/docs/getting-started/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " installation process the following steps are required to set up sakuli to work with multiple browsers. once the initial setup is done, we will dive right into our first test.\nwebdriver installation sakuli utilizes the webdriver protocol to remote control browsers during test execution. in addition to the browser itself, you need to install the corresponding webdriver as well. several wrapper packages can be found on npmjs.com, which allow the installation of the required binaries via npm.\nsince some users encountered issues with geckodriver on firefox, we recommend using chromedriver for now. we are working on fixes and workarounds for geckodriver.\ntherefore, chrome is the preferred browser for running sakuli tests at the moment. a suitable webdriver can be installed via:\nnpm i chromedriver or\nyarn add chromedriver there are also webdriver packages for ie and edge. macos already ships a webdriver for safari, so there is no need to install an additional package.\nattention: be careful to install the correct version of a webdriver package according to the installed browser version. to install e.g. chromedriver for chrome 73 you have to install:\nnpm i chromedriver@73.0.0 sakuli is not limited to work with only a single browser. when installing multiple webdriver packages, you can easily switch between different browsers.\nregarding windows users: you will have to manually add the respective webdriver location to your system path, otherwise sakuli will not be able to find and use it. once you installed a webdriver package via npm, you will be prompted with its installation path, so you can easily add it to your %path% variable.\nsample path: %userprofile%\\\\appdata\\\\roaming\\\\npm\\\\node_modules\\\\chromedriver\\\\lib\\\\chromedriver\\\\\nsakuli installation 3rd-party dependencies one of sakuli\u0026rsquo;s core components, nut.js, requires opencv. sakuli ships a pre-built version of opencv. nonetheless, the installation still requires some 3rd-party dependencies.\nwindows in order to install and run sakuli on windows you need two additional tools: python 2 and the windows build tools.\nto avoid eventual installation problems for windows users we recommend to first install python 2 on your system separately by downloading the required version from the official web page. afterwards you can install the windows build tools manually or via npm using:\nnpm install --global windows-build-tools or\nyarn global add windows-build-tools in case of errors while installing the windows build tools package via npm, please make sure that the powershell is available on your system path. additionally, you should install the windows build tools by using the powershell in administrative mode. see this issue.\nmacos on macos, xcode command line tools are required. you can install them by running: xcode-select --install\nlinux depending on your distribution, linux setups may differ.\nin general, sakuli requires:\n python 2 g++ make libxtst libpng  installation on *buntu: sudo apt-get install build-essential python libxtst-dev libpng++-dev\nthe installation process is an open issue and will be improved in the near future, so using sakuli will become even more enjoyable!\nsakuli installation we will now install sakuli in our newly created project by running:\nnpm i @sakuli/cli or\nyarn add @sakuli/cli this will install sakuli and its required dependencies.\nreference  opencv4nodejs robotjs  "
},
{
	"uri": "/docs/enterprise_features/",
	"title": "Enterprise Features",
	"tags": [],
	"description": "",
	"content": " enterprise features some features of sakuli require an enterprise license. please consult our overview to see and request packages and prices. after you registered for an enterprise subscription, you will get a license-key and an npm access token which are required to use enterprise features.\nassisted setup it is assumed that you have setup your environment as described in the getting started guide.\non the commandline, navigate to the root folder of your sakuli project (where the package.json file is located) and run the following command:\nnpx sakuli enable-enterprise this command starts an assistant which will guide you through the setup of enterprise features. the first question is regarding the sakuli-license key which you should have received after subscribing to an enterprise package.\n? would you like to enter your sakuli license information? (y/n) you can enter n when you have already entered the license information before.\nyou can enter y and paste the license key in the next prompt:\n? please enter your license key: same applies to the npm access token which can be pasted / entered in the next prompt:\n? please enter your npm key: the following prompt asks you about the enterprise features which you want to activate. you can use ↑ and ↓ to navigate the cursor and space to select or deselect a feature. pressing enter will submit your selection and start the setup process.\n? please select enterprise features to bootstrap (press \u0026lt;space\u0026gt; to select, \u0026lt;a\u0026gt; to toggle all, \u0026lt;i\u0026gt; to invert selection) ❯◯ forwarding to icinga2 ◯ forwarding to checkmk ◯ forwarding to omd sakuli will then configure the license information globally and add install and preconfigure the selected enterprise features in your project.\nyou can now just start using your feature:\n forwarding to icinga2 forwarding to checkmk forwarding to omd  the next sections is about how to setup enterprise features manually and in more detail.\nmanual setup with your active sakuli enterprise subscription you will receive an email with:\n sakuli license-key - contains information about your subscription and is used by sakuli itself and a npm-token - allows access to sakuli\u0026rsquo;s private enterprise packages on npm  there are several ways to handle these information. the most simple way for setting up your enterprise features is as follows (substitute the placeholders between the chevrons with the appropriate values):\nglobal configuration the most simple way to get your enterprise features to work is the following configuration (substitute the placeholders marked by the angle-brackets with its appropriate values):\non unix / osx echo \u0026#34;//registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt;\u0026#34; \u0026gt; ~/.npmrc echo \u0026#34;export sakuli_license_key=\u0026lt;put your personal sakuli-license-key here\u0026gt;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc\non windows echo //registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt; \u0026gt; %userprofile%\\.npmrc setx sakuli_license_key=\u0026lt;put your personal sakuli-license-key here\u0026gt;\nthe environment variables might not take effect in the command-line window where the commands above are entered. so you might need to open a new commandline when running the sakuli command.\nthese commands will set the npm-token and license key globally. this is good for a first setup on your machine but might have some shortcomings in more advanced situations. the following paragraphs describe alternative ways to provide npm-token and license information to your sakuli installation.\nnow you are ready to go for using sakuli with its enterprise features like\n checkmk icinga2 omd  per-project configuration of npm-token you can set the npm-token for each project by adding a .npmrc file to your project\u0026rsquo;s root directory:\non unix / osx # cd path/to/project echo \u0026#34;//registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt;\u0026#34; \u0026gt; .npmrc\non windows # cd path/to/project echo //registry.npmjs.org/:_authtoken=\u0026lt;put your personal npm-token here\u0026gt; \u0026gt; .npmrc\nthis command will create an .npmrc file with the necessary token configuration inside your specific project folder. every upcoming npm install will use this configuration.\nper-project configuration with environment variable if you don\u0026rsquo;t like to save the token in a file (because this file might be shared) you can configure it to use an environment variable:\non unix / osx echo \u0026#34;//registry.npmjs.org/:_authtoken=\\${npm_token}\u0026#34; \u0026gt; ~/.npmrc\non windows echo //registry.npmjs.org/:_authtoken=${npm_token} \u0026gt; %userprofile%\\.npmrc\non unix / osx npm_token=\u0026lt;put your personal npm-token here\u0026gt; npm i \u0026lt;enterprise-package\u0026gt;\non windows set npm_token=\u0026lt;put your personal npm-token here\u0026gt; npm i \u0026lt;enterprise-package\u0026gt;\nthis approach is frequently used in automation scenarios such as ci/cd pipelines and projects that are shared (e.g. via version control systems).\nit is usually not necessary to persist the token since you will seldomly run npm install that often.\nusing the license-key the license-key contains information about your subscription which will be checked by enterprise components before they are executed. in order to provide this license-key to sakuli you also have to set it as an environment variable. because the license-key is read on every single test execution it is useful to store it persistently on your system or set it in a script where the actual test is also called.\nthe name of the environment variable for the license-key is sakuli_license_key.\nmore about environment variables  an environment variable is a dynamic-named value that can affect the way running processes will behave on a computer. they are part of the environment in which a process runs. for example, a running process can query the value of the temp environment variable to discover a suitable location to store temporary files, or the home or userprofile variable to find the directory structure owned by the user running the process.\n - wikipedia, 08/2019\nso basically an environment variable is just a simple key-value pair provided to a certain process e.g. var_name=value. they can be set for each process or system-wide - so that they become accessible for each upcoming process.\nthe approach for integrating an environment variable depends on the respective operating system.\non windows to set up an environment variable on windows you have to:\n open start-menu and type env into the search mask  an entry \u0026lsquo;edit the system environment variables\u0026rsquo; should appear (click on it)  after the system properties dialog showed up  go to the advanced tab click on the button environment variables (at the bottom of the dialog)  you should see two tables including variable and value columns for user variables and system variables  there you can set, edit or delete environment variables permanently on your system (it is recommended to edit the system variables table if possible). a more detailed guide can be found here.\nalternatively you can use rapid environment editor which is a nice tool for editing environment variables on windows.\nin case of a more restrictive environment - where it is not possible to edit environment variables that easily - you can set them in a batch script:\nrun-sakuli.bat set sakuli_license_key=\u0026lt;personal_license\u0026gt; sakuli run .\non linux or osx on linux or osx it is usually a file which sets up the environment for certain processes:\n ~/.bashrc on linux ~/.profile on osx  these files can be changed with every text editor to add, edit or remove environment variables. an environment variable is defined by:\nexport variable_name=value a new variable can be added with the command:\necho \u0026#34;export variable_name=value\u0026#34; \u0026gt;\u0026gt; ~/.bashrc # linux echo \u0026#34;export variable_name=value\u0026#34; \u0026gt;\u0026gt; ~/.profile # osx "
},
{
	"uri": "/docs/enterprise_features/e2e/",
	"title": "Container",
	"tags": [],
	"description": "",
	"content": " pre-configured container once you obtained a sakuli enterprise license your docker-user will be granted access to the private sakuli test container image. this image is ready to go and ships with already installed:\n sakuli icinga2 / checkmk / omd forwarder vnc / novnc chrome / firefox (incl. webdriver)  1 obtaining the image the registered docker-hub user will then be able to pull the private image:\ndocker pull taconsol/sakuli:\u0026lt;image_tag\u0026gt; sakuli test containers do not provide a latest tag. you will always have to specify the exact version of sakuli you intend to use in your containerized tests.\ncontainers are tagged according to sakuli versions, so in order to use sakuli v2.1.2 in a test, one would pull the following image:\ndocker pull taconsol/sakuli:2.1.2  sakuli does not support a latest tag. when running a containerized test one always has to specify the exact version to use to ensure consistency. you can find a list of available tags on dockerhub\n 2 running sakuli test containers containerized sakuli tests require a valid sakuli license token which has to be provided via the sakuli_license_key environment variable.\ndocker allows to pass environment variable along other parameters when starting a new container:\ndocker run --rm -p 5901:5901 -p 6901:6901 -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; [--shm-size=2g] taconsol/sakuli:2.1.2 parameters:\n --rm: the test container will be removed after execution, not just stopped -p: port forwardings. vnc is available on port 5901, the html5 webvnc view is exposed on port 6901 on the docker host -e: environment variable flag which is used to provide the sakuli_license_key to the container \u0026ndash;shm-size: (optional parameter) increases the size of the shared memory space of the container. the default value is 64mb. this might be required when testing larger websites. indicators that a shared memory enlargement is required are container crashes, the erroneous loading of websites or invalid session id errors due to crashed browsers.\n   sakuli test containers run as non-root user, the default uid is 1000.\n 3 anatomy of a containerized sakuli test in general, the structure of a containerized sakuli test does not differ from any other sakuli test. no changes are required when executing a test inside a container. the only configuration we have to provide, is information about how and which tests should be executed.\n4 configuring a containerized test the default behaviour of a sakuli test container is to run npm test to execute tests, so to run a custom test we have to:\n provide the test project to the container (as shown in 4.2.x) specify the location of our test project inside the container configure what to execute on npm test  4.1 provide the test project to the container there are two common ways to provide files to a container:\n bind mounts extending a base image  4.1.1 bind mounts when running a docker container it is possible to mount a file or directory on the docker host into a container. this mechanism can be used to provide a sakuli test to a test container:\ndocker run -v /path/to/test/project/on/host:/sakuli_test -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; taconsol/sakuli:2.1.2 by adding the -v parameter we\u0026rsquo;re mounting the root folder of our sakuli test at /path/to/test/project/on/host (where the package.json file is located) on our host machine at /sakuli_test inside our test container. inside the test container we can now run a sakuli test via sakuli run /sakuli_test/test_suite_folder.\nbind mounts are easy to use and very useful during development.\nfor further information, please refer to the docker documentation on bind mounts\n4.1.2 extending a base image once we finished our test case and are ready to put it to work, bind mounts might become a bit cumbersome. now that the test is done and wont change frequently, it would be feasible to build an explicit docker image for our test.\nwe can do so by creating our own dockerfile next to our project directory:\n  /folder/containing/dockerfile/and/project  dockerfile  testsuite-a  package.json  \u0026hellip;  from taconsol/sakuli:2.1.2 add ./testsuite-a \\$home/sakuli_testsuite using this dockerfile we can now build our own test image by running\ndocker build -t name-of-my-image . inside the folder where our dockerfile is located.\nwe can now run our newly built image via:\ndocker run -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; name-of-my-image  when working with added files and folders inside a container, one has to ensure correct file permissions for added files.\n 4.2 specify the location of our test project inside the container now that our test files are available inside the container, we need to find a way to configure where our project is located.\nthis can easily be done by setting the sakuli_test_suite environment variable to the respective path:\ndocker run -v /path/to/test/folder:/sakuli_test -e sakuli_test_suite=/sakuli_test -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; taconsol/sakuli:2.1.2 when building new images, this setting can also be added to the dockerfile:\nfrom taconsol/sakuli:2.1.2 add ./testsuite-a $home/sakuli_testsuite env sakuli_test_suite=$home/sakuli_testsuite 4.3 configure what to execute on npm test the main configuration file of a npm project is its package.json file. within this file it\u0026rsquo;s possible to configure npm-scripts, a handy way to execute scripts inside an npm project.\nan empty project initialised via npm init already contains one script: npm test\n... \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, ...  npm test is the default way of executing tests in an npm project, so sakuli tests should be executed this way, too!\nsince sakuli is available in our project, we can run our test by simply calling sakuli run ... on npm test. our test suites are located within the same folder as our package.json, so a test suite can be run via:\n... \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;sakuli run /path/to/your/test/suite\u0026#34; }, ...  4.3.1 troubleshooting this topic covers possible errors when running containerized sakuli tests.\n4.3.1.1 error: invalid elf header some parts of sakuli are platform-dependent, so the node_modules folder of a sakuli project contains platform specific libs. sakuli containers are running a linux base image, so when mounting a project which has been developed on a non linux machine, e.g. macos, the node_modules folder will contain libs specific to macos.\ntrying to run such a test inside a sakuli container will therefore fail with an error message similar to this:\nunhandledpromiserejectionwarning: error: /test/node_modules/robotjs-node10/build/release/robotjs.node: invalid elf header a simple way to resolve the dependency problem is to delete the node_modules folder. if your test project does not require libraries other than sakuli, the correct libraries globally installed in sakuli containers will be used.\nin case your test project requires additional dependencies, it\u0026rsquo;s possible to run npm install before executing the sakuli test.\n... \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;npm i \u0026amp;\u0026amp; sakuli run /path/to/your/test/suite\u0026#34; }, ...  5 viewing / configuring test execution sakuli test containers allow to configure specific details of their runtime environment.\n5.1 vnc access sakuli containers provide access to running containers via vnc on ports 5901 and 6901. by specifying port forwardings (-p) it is possible to configure which ports will be used to connect to a running container on the host system.\ndocker run --rm -p 5901:5901 -p 6901:6901 -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; taconsol/sakuli:2.1.2 the example above forwards container ports 5901 and 6901 to the same ports on the host system.\ndocker run --rm -p 5000:5901 -p 6000:6901 -e sakuli_license_key=\u0026lt;your sakuli license key\u0026gt; taconsol/sakuli:2.1.2 in this example container port 5901 is forwarded to port 5000 on the host system, port 6901 is forwarded to port 6000 on the host system. localhost:5000 would be used to connect to the container via vnc client, on localhost:6000 a webvnc view is available in the browser.\n the default password to access a container via vnc is vncpassword. it is highly recommended to change this password in production environments. see section #5.2 for details\n 5.2 configuring vnc access the following vnc environment variables can be overwritten at the docker run phase to customize your desktop environment inside the container:\nvnc_col_depth, default: 24 // color depth vnc_resolution, default: 1280x1024 // screen resolution vnc_pw, default: vncpassword // vnc password vnc_view_only, default: false // run in view only mode, no keyboard / mouse interaction possible for example, the password for vnc could be set like this:\n~\\$ docker run -p 5901:5901 -p 6901:6901 -e vnc_pw=my-new-password taconsol/sakuli:2.1.2 5.3 container user per default all container processes will be executed with user id 1000.\n using root (user id 0):\nadd the --user flag to your docker run command:\n~\\$ docker run -it -p 5901:5901 -p 6901:6901 --user 0 taconsol/sakuli:2.1.2  using user and group id of host system\nadd the --user flag to your docker run command:\n~$ docker run -it -p 5901:5901 -p 6901:6901 --user $(id -u):\\$(id -g) taconsol/sakuli:2.1.2   6 custom certificates internal infrastructure often uses custom certificates with own root cas etc. things like untrusted certificates cause sakuli tests to fail, since no connection to an seemingly insecure host will be established (insecurecertificateerror).\nunfortunately, browsers use their own certificate store, which requires some additional work to add custom certificates.\n6.1 adding custom certificates in order to add custom certificates to a sakuli container, one has to provide two things:\n a directory containing certificates for import (_.crt, _.cer, *.pem) an environment variable called sakuli_trusted_cert_dir which holds the path to the directory where certificates for import are located inside the container  if the environment variable has been set, a startup script will pick up all certificates contained in the given folder and import each of them to all available browser certificate stores within $home, supporting both cert8.db databases for older browser versions as well as cert9.db files for recent browser versions.\n6.2 sample ~$ docker run -v /path/to/certificates/:/certificate_import -e sakuli_trusted_cert_dir=/certificate_import/ taconsol/sakuli:2.2.0 6.3 firefox by default, a firefox test uses a new, blank profile for each test run. in order to pick up the added certificates, a firefox profile containing the appropriate certificate database has to be specified via selenium.firefox.profile=/path/to/profile/folder in testsuite.properties. in order to make this process easier, a dedicated firefox profile for use with certificates is located at /headless/firefox-certificates to be used, instead of the generated profiles in /headless/.mozilla/firefox/long_random_id.default.\nattention: if this property is not set, added certificates will have no effect.\n7 overview environment variables    environment variable default value description     sakuli_test_suite \\$home/demo_testcase path to sakuli testsuite to be executed   sakuli_license_key  sakuli license to use the container   vnc_col_depth 24 color depth of container monitor   vnc_resolution 1280x1024 screen resolution of container   vnc_pw vncpassword password to access novnc/vnc connection   vnc_view_only false enable/disable view-only mode   node_no_warnings 1 enable/disable node warnings (deprecations etc.)   npm_token  npm token to access npmjs.com registry   sakuli_trusted_cert_dir  directory containing custom certificates for import    8 summary once we have\n added our test to the container (via bind mount or our own image) configured where our test project is located (via sakuli_test_suite environment variable) set up our test script (optional) configured the container runtime environment  our test will run automatically after the container started.\n"
},
{
	"uri": "/docs/writing_tests/screenshot/",
	"title": "Screenshot",
	"tags": [],
	"description": "",
	"content": " screenshot based testing a lot of e2e scenarios exceed the capabilities of browsers and webdrivers. this might include common use-cases like a drag and drop from the host system to a webpage or exporting a report into a spreadsheet or pdf-format. in these cases, your web-based tests can be extended to also validate behavior and invoke interactions outside the browser, all within a single test.\nof course, you can also use sakulis native testing power on its own, e.g. rich-client testing of sap, office or proprietary software systems. sakuli accomplishes its native capabilities by scanning the whole screen (or a dedicated region) on a stand-alone computer or in headless container screens, searching for provided image patterns.\nscreenshot based actions are relying on an abstract region class, which represents an abstract region on the desktop. when creating a new instance without parameters, a region spans over the whole desktop. but, it is also possible to create new regions by specifying left, top, width and height parameters.\nthe following example represents a test which drags a source element to a target region. in this demo scenario, both source and target are both located on screen via template image. to reproduce this scenario, you need to capture screenshots of the egg and the pan.\n(async () =\u0026gt; { const testcase = new testcase(\u0026#34;native_keyboard_demo\u0026#34;); const url = \u0026#34;https://codepen.io/naturalhanglider/full/jqmwoq\u0026#34;; const screen = new region(); const env = new environment(); try { await _navigateto(url); await env.setsimilarity(0.8); await screen .find(\u0026#34;source_egg.png\u0026#34;) .mousemove() .draganddropto( await screen.find(\u0026#34;target_pan.png\u0026#34;) ); await _wait(3000); } catch (e) { await testcase.handleexception(e); } finally { testcase.saveresult(); } })();  -- your browser does not support the video tag.   the draganddropto(...) methods always move straight to the target region. in order to follow a more complex path, it is also possible to perform the drag gesture manually. once the source image has been located on the screen, sakuli moves the mouse to its location, presses and holds the left mouse button. afterwards, it locates the target image, moves the mouse there while still holding the mouse button and releases it, once it reaches the target location. to reproduce this scenario, you need to capture screenshots of the egg and the pan.\n(async () =\u0026gt; { const testcase = new testcase(\u0026#34;native_demo\u0026#34;); const url = \u0026#34;https://codepen.io/naturalhanglider/full/jqmwoq\u0026#34;; const screen = new region(); const env = new environment(); try { await _navigateto(url); await env.setsimilarity(0.8); await screen.find(\u0026#34;source_egg.png\u0026#34;).mousemove().mousedown(mousebutton.left); await new region(0, 0, 10, 10).mousemove(); await new region(500, 700, 50, 100).mousemove(); await screen.find(\u0026#34;target_pan.png\u0026#34;).mousemove().mouseup(mousebutton.left); await _wait(3000); } catch (e) { await testcase.handleexception(e); } finally { testcase.saveresult(); } })().then(done); "
},
{
	"uri": "/docs/getting-started/firsttest/",
	"title": "First Setup",
	"tags": [],
	"description": "",
	"content": " setup setup your first test since v2.2.0 sakuli provides an easy to use mechanism to initialize testcases and testsuites.\nnpx sakuli create project . my-sut this will create all necessary files and folders to start writing your first sakuli test right away. with this, you can skip the next section and directly start to write your first test\nsetup the project manually since we wanted to keep sakuli mostly compatible to v1, the file layout looks basically the same for testsuites.\neach testsuite is located in its own particular folder. generally, a testsuite represents the system you want to test. therefore, you need to create that folder in your project root (where the package.json file is located):\nmkdir my-sut to describe the testsuite and its testcases, two additional files are needed: testsuite.properties and testsuite.suite. these files are required for backwards compatibility (they might not be necessary in the future but will at least be supported). these files should be added to the my-sut folder:\ncd my-sut echo \u0026gt; testsuite.suite echo \u0026gt; testsuite.properties we can add the following contents to testsuite.properties:\necho testsuite.id=my-sut \u0026gt; testsuite.properties this is the minimum configuration for using sakuli. the .properties file adds some metadata needed by the sakuli-runtime and can be changed to configure other things like forwarders or the default browser for the execution.\nthe testsuite.suite file tells sakuli which testcases are running. the format is:\n\u0026lt;folder-name\u0026gt;/\u0026lt;file-name\u0026gt;.js \u0026lt;start_url\u0026gt; the actual testcase file must be placed inside a folder (this is due to the format forced by sahi in sakuli v1). the start-url also needs to be added but has no effect in v2+.\nwith this in mind, we can add a testcase file:\nmkdir my-testcase echo \u0026gt; my-testcase/testcase.js and add the following information to the testsuite.suite file:\necho my-testcase/testcase.js https://sakuli.io \u0026gt; testsuite.suite after the setup you can add the actual test code to my-testcase/testcase.js:\n(async () =\u0026gt; { // 1  const testcase = new testcase(); // 2  try { // actual testcode goes here  } catch (e) { await testcase.handleexception(e); // 3  } finally { await testcase.saveresult(); // 4  } })(); // 5 let us examine this piece of code:\n the whole test is wrapped in an async immediate invoked function. it allows us to use the async/await syntax of es6. since sakuli makes heavy use of async operations, it makes your code more readable. to provide sakuli information about our actual testcase, we create a testcase object, which handles the execution of a testcase. if any error occurs during testing, it will be redirected to the testcase object. it triggers sakuli\u0026rsquo;s internal error handling e.g. taking a screenshot of the actual failed test execution. regardless of a failed or passed test execution, sakuli saves all results. this is more like a legacy artifact and will be removed in the future. the () at the end of this line will invoke the defined function. since v2.2.0 sakuli is able to detect this invocation without explicitly chaining the call of done function like in previous versions (it is still possible to add .then(done))  write your first test let us write a simple test using the sakuli.io homepage as test subject. this test will verify if our \u0026ldquo;getting started\u0026rdquo; guide that you are reading at this very moment is still accessible.\n(async () =\u0026gt; { const testcase = new testcase(); try { await _navigateto(\u0026#34;https://sakuli.io\u0026#34;); // 1  testcase.endofstep(\u0026#34;open landing page\u0026#34;, 5, 10); // 2  await _click(_link(\u0026#34;getting started\u0026#34;)); // 3  await _click(_link(\u0026#34;initialization\u0026#34;)); testcase.endofstep(\u0026#34;navigate to initialization section\u0026#34;, 3, 5); await _highlight(_code(\u0026#34;npm init\u0026#34;)); // 4  testcase.endofstep(\u0026#34;find npm init code sample\u0026#34;); } catch (e) { await testcase.handleexception(e); } finally { await testcase.saveresult(); } })();  since we are dealing with a web test, the first thing we want to do is to _navigateto our target page. instead of manually setting up the correct webdriver instance, we just have to provide a target url. sakuli will take care of the rest for us. await indicates that we are patiently waiting for our page to load before we continue with our next testing step. once our initial page load has been completed, it is of our great interest to know how long it took to render. when it comes to runtime, sakuli does not only measure the execution time of testcases, but also allows to split a single testcase into several logical steps. this way it becomes possible to accurately measure the runtime of certain processes like e.g. login, shopping cart, checkout and so on. by calling testcase.endofstep(\u0026quot;open landing page\u0026quot;, 5, 10);, we are ending our first step, the initial page load. additionally, it is also possible to specify warning and critical thresholds for each step. whenever a step exceeds one of these values, the result will change from ok to warning or critical. with sakuli it becomes very easy to interact with web elements. in our current example, we want to _click a _link which is identified by some given text. once again, we do not have to take care of many details, as sakuli will do most of the heavy lifting for us. we are just passing the link text to sakuli, which will search for our desired element using multiple identifiers. this way we do not have to worry about using an id, a css selector or something else to identify our element. as we have already seen in our first test action, await will wait until the test action has been completed. in some cases, it is really helpful to visually verify test execution. sakuli comes with a built-in _highlight function, which will highlight an element with a bright red border. although being useful, _highlight should be used carefully since it will increase the overall testing runtime.  execute your first test since sakuli 2 is built with node, there are at least two different ways to execute a sakuli test. we will take a look at each one of them. organizing tests as npm projects makes it easier for you to distribute testcode. everything required to execute the test is described in a project config, so tests should be ready to use after running npm install inside a project. 👍\nnpx because of the way we have set up and configured our project in this guide, sakuli is only available to this particular project. npx is a really handy tool, which allows us to execute our sakuli cli directly from the command line, even though we did not add it to the system path.\nin order to run our first test, we just have to execute npx sakuli run my-sut inside our project folder (e.g. /tmp/sakuli_starter on *nix). by default, sakuli will pick up the browser configured in the testsuite.properties file, but with npx it is possible to change the browser on the fly:\nnpx sakuli run my-sut --browser chrome this command will execute our test in chrome.\nregardless of the browser choice, as long as our site did not slow down, you should see a successful test result, similar to the image on the right. the advantage of running your tests with npx is the flexibility to easily customize your test runs without having to edit files.\n"
},
{
	"uri": "/docs/cookbook/invalid-session-id/",
	"title": "Error: Invalid session id",
	"tags": [],
	"description": "",
	"content": " oh noes! sakuli crashed with an \u0026ldquo;invalid session id\u0026rdquo; error! when sakuli crashes with an \u0026ldquo;invalid session id\u0026rdquo; error, the webdriver itself crashed or least closed the session the sakuli test or check is using. such a behavior mostly occurs, when the provided resources for the sakuli execution are insufficient. when testing bigger websites, please check if enough shm space is available.\n running sakuli container with \u0026ndash;shm-size increasing shared memory on openshift  "
},
{
	"uri": "/docs/cookbook/container/",
	"title": "Run Container",
	"tags": [],
	"description": "",
	"content": " how to run a container with sakuli tests  sakuli container are only available with an active sakuli subscription.\n the following how-to aims to help unexperienced users getting started with sakuli containers. a sakuli container ships with pre-installed sakuli, monitoring forwarder and other additional features, it is not necessary to install anything on your docker-host, except for docker.\ndownload the image with your logged-in docker-user (which is authorized to access the repository with an active subscription), you first need to download the sakuli image: docker pull taconsol/sakuli:2.2.0\nfolder structure and necessary files you will need a proper sakuli test setup on your docker-host. do one of the following to bootstrap this setup:\neither clone the git repository git clone git@github.com:sakuli/container_bootstrap.git sakuli-container_bootstrap\nor\ndownload the following zip download as zip  after cloning the repo / unzipping the file, you will have a folder structure like this with the proper files to run a test using a sakuli container:  run open a terminal and navigate to the folder \u0026ldquo;sakuli-container_bootstrap*\u0026ldquo;. within this folder, run the following docker command (you will have to insert your active sakuli license key): docker run --rm -v $(pwd):/suite -p 5901:5901 -p 6901:6901 -e sakuli_test_suite=/suite -e sakuli_license_key=yourlicensekey taconsol/sakuli:2.2.0\nwatch the magic you can use the novnc feature to have a live-view of what is happening within the container by opening the following link on your docker-host while the container is running and a test is executed: http://localhost:6901/?password=vncpassword\nwhat´s more? have a look at our enterprise documentation about container, forwarder etc. to get a more in-depth knowledge on what is happening and on how to customize the execution of sakuli tests.\n"
},
{
	"uri": "/docs/cookbook/proxy/",
	"title": "Container and Proxies",
	"tags": [],
	"description": "",
	"content": " container behind proxies to configure a proxy within your docker container, set one or both of the following environment variables within your docker run command.\n-e http_proxy=http://server-ip:port/ -e https_proxy=http(s)://server-ip:port/  use a http_proxy for http target sites and https_proxy for https sites, if you switch between secure and insecure sites or just to be sure not to worry about it, you can also define both proxies at the same time, e.g. like this:\ndocker run --rm -p 5901:5901 -p 6901:6901 -e http_proxy=http://server-ip:port/ -e https_proxy=http(s)://server-ip:port/ -e sakuli_license_key=yourlicensekey taconsol/sakuli:2.2.0 "
},
{
	"uri": "/docs/cli/",
	"title": "CLI",
	"tags": [],
	"description": "",
	"content": " sakuli cli commands sakuli create project npx sakuli create project [ \u0026lt;path\u0026gt; ] [ \u0026lt;suitename\u0026gt; ] [ --force | -f ] [ --package ] generates a default project structure positionals: path path to create testsuite [optional][default: $pwd] suitename name of testsuite [optional][default: sakuli_test_suite] options: --force (alias -f) forces sakuli to create testsuite --package create additional package.json for testsuite this creates a sakuli testsuite folder with the testsuite.suite and testsuite.properties files and a case1 folder containing an empty check.js. with the --package option, it is possible to create an additional package.json. further information on how to set up a sakuli project and the needed files can be found here.\nsakuli create masterkey npx sakuli create masterkey [ --algorithm ] generates a new masterkey positionals: algorithm the algorithm to create a key for [optional][default: \u0026#34;aes-128-cbc\u0026#34;] this command outputs a masterkey which can be used to encrypt a secret with the sakuli encrypt command or to decrypt a secret in a testcase with a sakuli function like environment.decryptsecret().\nsakuli enable-enterprise npx sakuli enable-enterprise configures and enables enterprise features this command starts an assistant which will guide you through the setup of enterprise features. more information on how to use the enable-enterprise command can be found here.\nsakuli encrypt npx sakuli encrypt \u0026lt;secret\u0026gt; --masterkey encrypts a secret via provided masterkey positionals: secret the secret to encrypt [required] options: --masterkey the masterkey used for encryption [required] to use this command it is necessary to create a masterkey with npx create masterkey first. with npx sakuli encrypt you can now encrypt a secret or password which then can be decrypted in the sakuli testcase with one of the decryption functions like environment.decryptsecret().\nsakuli migrate npx sakuli migrate \u0026lt;path\u0026gt; transforms all legacy testsuites into new syntax positional path path to a legacy suite [required] since sakuli had some minor changes in the syntax with v2, old sakuli v1 testcases need to be adapted to the new syntax. with this command sakuli takes over this task.\nsakuli run npx sakuli run \u0026lt;path\u0026gt; runs a sakuli suite positionals: path path to sakuli suite [required] "
},
{
	"uri": "/docs/cookbook/frames/",
	"title": "Frames",
	"tags": [],
	"description": "",
	"content": " how can i handle frames or iframes in sakuli? since v2.2.0 sakuli will automatically detect different frames (and iframes) and will search for elements in each frame when the element can not be found in default frame. but it is also possible to switch between frames manually by using the iframe webelement or its respective index.\nconst myiframe = await _fetch(_iframe(\u0026#39;framename\u0026#39;)); await driver.switchto().frame(myiframe);  const frameindex = 0; await driver.switchto().frame(frameindex);  "
},
{
	"uri": "/docs/enterprise_features/s2i/",
	"title": "S2I Image",
	"tags": [],
	"description": "",
	"content": " s2i image sakuli enterprise comes with ready-to-use source to image (s2i) containers for redhat openshift. using this builder container, it is easily possible to create deployable sakuli images shipped with a test suite straight from your code repository.\nsetup to setup the source to image builds on your openshift cluster, it is required to import the images from taconsol/sakuli-s2i. to achieve this, you have to create a docker-registry secret with your \u0026lt;docker-username\u0026gt; and \u0026lt;docker-password\u0026gt; and link it to your builder service account to authenticate on docker.io during build. once you obtained a sakuli enterprise license your docker user will be granted access to the private sakuli s2i images.\noc create secret docker-registry dockerhub-sakuli-secret \\  --docker-server=docker.io \\  --docker-username=\u0026lt;docker-username\u0026gt; \\  --docker-password=\u0026lt;docker-password\u0026gt; \\  --docker-email=unused oc secrets link builder dockerhub-sakuli-secret after you\u0026rsquo;ve created and linked the secret, you can import the images from the secured registry.\noc import-image sakuli-s2i \\  --from=docker.io/taconsol/sakuli-s2i \\  --confirm \\  --scheduled=true \\  --all=true note: the oc import-image statement is configured to not only import all available sakuli s2i images but also to check for updates automatically.\nadding custom certificates the following requirements have to be met to add custom certificates to a sakuli s2i build:\n an openshift secret holding custom certificates a volume mount for the required certificates an environment variable called sakuli_trusted_cert_dir which holds the path to the directory where certificates for import are located inside the container  certificate secret oc create secret generic custom-certs \\  --from-file=my-first-cert.cer=/path/to/first/cert.cer \\  --from-file=another-cert.crt=/path/to/another/cert.crt \\  --from-file=last-cert.pem=/path/to/last/cert.pem the above snippet will create a new secret called custom-certs which holds three key-value pairs storing our certificates.\ncertificate volume mount the next step to include custom certificates is to mount them in a test container.\nspec: containers: - name: ... image: ... volumemounts: - name: custom-certs mountpath: /etc/custom-certs volumes: - name: custom-certs secret: secretname: custom-certs we are defining a volume custom-certs which holds the content of our previously generated secrets. by mounting this volume in our test container we\u0026rsquo;re able to provide the custom certificates to the container at runtime.\nif one does not want to mount all certificates, certificates can be selected via subpath:\nspec: containers: - name: ... image: ... volumemounts: - name: custom-certs subpath: first-cert.cer mountpath: /etc/custom-certs/first-cert.cer  - name: custom-certs subpath: another-cert.crt mountpath: /etc/custom-certs/another-cert.crt  volumes: - name: custom-certs secret: secretname: custom-certs sakuli_trusted_cert_dir variable the final step to enable custom certificates is to provide the certificate location via environment variable:\nspec: containers: - name: ... image: ... env: - name: sakuli_trusted_cert_dir value: /etc/custom-certs  volumemounts: - name: custom-certs mountpath: /etc/custom-certs volumes: - name: custom-certs secret: secretname: custom-certs firefox by default, a firefox test uses a new, blank profile for each test run. in order to pick up the added certificates, a firefox profile containing the appropriate certificate database has to be specified via selenium.firefox.profile=/path/to/profile/folder in testsuite.properties. in order to make this process easier, a dedicated firefox profile for use with certificates is located at /headless/firefox-certificates to be used, instead of the generated profiles in /headless/.mozilla/firefox/long_random_id.default.\nattention: if this property is not set, added certificates will have no effect.\ncreating an s2i build the following build-config template is ready to use to create sakuli s2i builds for various repositories and test suites. just copy and save the s2i build template as sakuli-s2i-build-template.yml. to process the template some additional information is required that are not part of the template. first of all, you have to provide a sakuli_license_key to be able to execute the images resulting from the build process and you have to specify the repository to pull the test case from as testsuite_repository_url. to install such a basic setup on your openshift cluster, just use the following command and replace the placeholder with actual values.\noc process -f sakuli-s2i-build-template.yml \\  sakuli_license_key=\u0026lt;sakuli_license_key\u0026gt; \\  testsuite_repository_url=\u0026lt;testsuite_repository_url\u0026gt; | oc apply -f - advanced s2i build configuration the provided template comes with a lot of optional parameter to customize your build process. the following table contains all available parameters. additional parameters are specified in the same way as seen in the creating an s2i build section.\n  parameter optional description default value   sakuli_license_key no sakuli2 license key.    testsuite_repository_url no git source url containing the test suite.    testsuite_repository_ref yes git branch/tag reference. master   image yes name for the target image to be build. sakuli-s2i-testsuite   image_tag yes tag to push build images to. latest   testsuite_context_dir yes source folder where the test suite is located.    testsuite_repository_secret yes secret to access the testsuite repository.    builder_image yes name of the builder image. sakuli-s2i   builder_image_tag yes tag of the builder image to use. latest   s2i build template apiversion: v1 kind: template labels: template: sakuli-s2i-testsuite-image-build metadata: annotations: description: build config to create a ready to run sakuli2 container with the specified testsuite tags: consol, sakuli2, custom-image, s2i, source-to-image name: sakuli-s2i-testsuite-image-build parameters: - description: name for the target image of the build. name: image required: true value: sakuli-s2i-testsuite - description: image tag of the target image. name: image_tag required: true value: latest - description: sakuli2 license key. name: sakuli_license_key required: true - description: git source url containing the test suite. name: testsuite_repository_url required: true - description: git branch/tag reference. name: testsuite_repository_ref value: \u0026#34;master\u0026#34; required: true - description: source folder where the test suite is located. name: testsuite_context_dir - description: secret to access the testsuite repository. name: testsuite_repository_secret - description: name of the builder image. name: builder_image required: true value: sakuli-s2i - description: tag of the builder image to use. name: builder_image_tag required: true value: latest objects: - apiversion: v1 kind: imagestream metadata: labels: application: ${image} name: ${image} - apiversion: v1 kind: buildconfig metadata: labels: build: ${image} name: ${image} spec: output: to: kind: imagestreamtag name: ${image}:${image_tag} source: type: git git: ref: ${testsuite_repository_ref} uri: ${testsuite_repository_url} contextdir: ${testsuite_context_dir} sourcesecret: name: ${testsuite_repository_secret} strategy: type: source sourcestrategy: from: kind: imagestreamtag name: ${builder_image}:${builder_image_tag} env: - name: \u0026#34;sakuli_license_key\u0026#34; value: ${sakuli_license_key} triggers: - imagechange: {} type: imagechange - type: configchange increasing shared memory of a sakuli containers on openshift the result of an s2i build is a ready to run sakuli container that can be deployed on openshift as a pod, job or cronjob.\ndepending on the size of the websites to be tested, it might be required to provide more shared memory space to the container. indicators that a shared memory enlargement is required are container crashes, the erroneous loading of websites or invalid session id errors due to crashed browsers. in order to do so, two steps are required.\n creating a volume to be used as shared memory mounting the shared memory volume into the container  the following snippet shows the required configuration for a pod deployment:\napiversion: v1 id: sakuli-test kind: pod metadata: name: sakuli-test labels: name: sakuli-test spec: volumes: - name: dshm emptydir: medium: memory containers: - image: mysakulitest:latest name: mysakulitest ... volumemounts: - mountpath: /dev/shm name: dshm  more information concerning shared memory on openshift can be found in the okd documentation.\n"
},
{
	"uri": "/docs/writing_tests/webtests/",
	"title": "Webtests",
	"tags": [],
	"description": "",
	"content": " web tests for dom based testing most of the functions from sahi tests can be used (please note that sakuli only implements the open source apis).\nthe main difference between sakuli v1 and sakuli v2 is the usage of promises in the action api, meaning that you have to await a click for example.\non the other hand, element selectors remain synchronized functions but will not do the actual dom fetching anymore. while an expression like var $e=_link('sakuli') did an actual dom-access in sakuli v1.x, it returns a kind of abstract query for an element now. so, action can fetch this element whenever it is required.\na detailed list of all available functions can be found in the sahi api interface,\naccessor api the accessor api is described in the accessor api interface.\nsakuli uses the concept of reusable queries rather than directly working on an element-object (like in selenium). sakuli offers an expressive set of accessors like _div, _textbox or _table. these accessors will not return an actual element or any reference to it. rather it will create a sahielementquery. this query can then be used in various actions like _click, _highlight or _isvisible. this concept could be compared with locators in selenium.\nthis architecture gives us two nice benefits:\n compatibility with sahi api since sakuli handles the actual fetching and validation of an element by performing retries, refreshes, implicit wait etc. which reduce annoying issues with selenium a lot (e.g. staleelementreferenceerror)  most accessors are defined in the same way: they are functions that take an accessoridentifier as a first parameter and a variadic list of relations:\n_name(identifier, ...relations): sahielementquery  the accessor adds a static locator to the returned query. since\na query object consists of a locator, an identifier and a list of relations, we will eventually get an entire query object. the locator basically is a css element selector which you would expect from the accessor name - so _div for example adds by.css('div'), _textbox adds by.css('input[type=\u0026quot;text\u0026quot;], input:not([type])') and so on.\nelementqueries since sakuli encapsulates the creation (through accessors) and the application (e.g. through actions) of a sahielementquery, a user will rarely get in touch with these objects directly. nevertheless, it is good to understand how sakuli works with queries. let us consider this example:\nawait _click(_button(\u0026#39;sign in\u0026#39;));  the following will happen under the hood:\n _button creates a query with a locator to a button element and with 'sign in' as an identifier and an empty list of relations\n this query is passed to the _click action. this action uses the accessorutil to fetch an element. it will:\n fetch a list of all elements from the locator reduce the list based on the relations (skipped when this list is empty) reduce the list with the identifier logic return the first entry of the remaining elements list   identifier the identifer is another relict from sahi that can be one of the following types:\n   type effect     number the identifier is considered as index. sakuli picks the element at this index (zero-based) in step 2.3   regexp tests this regexp against the following attributes of each element in the list at step 2.1: [aria-describedby], [name], [id], classname, innertext, value, src   string the string is normalized and wrapped into a regexp, therefore the same logic as for regexp is applied   accessoridentifierattributes this could be an object with the properties sahiindex and/or sahiindex, sahitext, classname. the first two are handled like a number or a string identifer, respectively. the latter one works like a string identifier which only checks for the classname property     since we mostly apply the logic of sahi comparisons against the class attribute are pretty dumb. while the attribute value is semantically a space separated list of class names. it is just handled as a usual string in sahi (and therefore also in sakuli so far).\n action api the action api is described in the action api interface.\nactions usually invoke a selenium action sequence with an activated bridge mode to cover compatibility to most webdriver implementations. an action accepts a sahielementquery or a webelement and tries to perform the action on this element several times. this approach reduces the count of staleelementreferenceerrors dramatically, especially when a query is used.\n_eval beside the fact that actions work asynchronously now, they behave like in sahi. one exception is the _eval method, which accepts a string now containing some javascript code, which is performed on the website by the webdriver implementation (see executeasyncscript method of seleniums thenablewebdriver).\nconst windowouterheight = await _eval(`return window.outerheight`)  fetch api the fetch api is described in the fetch api interface.\nthese methods are useful to get deeper access to elements and element-attributes:\nconst [x,y] = await _position(_image(\u0026#39;funny-cat-image.png\u0026#39;));  or let you perform checks (e.g. if an element exists).\nif(await _exists(_div(\u0026#39;cookie-banner\u0026#39;))) { await _click(_button(\u0026#39;i agree\u0026#39;)) }  selenium fallbacks since sakuli uses seleniums webdriver it also provides various ways to access the functionality of this backend.\n it is recommended to use sakulis built-in functionalities rather than work with the driver instances or any webelement directly. at the moment, sakuli is built upon selenium. nevertheless, a switch to other technologies in the future is possible. downwards compatibility is only possible for sakulis built-in functionalities. direct use of webdriver instance methods is not supported.\n webdriver instance sakuli test scripts provide a globally accessible object of the current webdriver instance which can be used to invoke its native methods directly. this might be useful for switching between frames:\nawait driver.switchto().frame(1); await _click(_div(\u0026#39;element-in-frame-1\u0026#39;)); await driver.switchto().defaultcontent();  webelement instances the fetch api provides the _fetch function which returns the native webelement instance from seleniums webdriver for a query:\nconst webelement = await _fetch(_image(\u0026#39;funny-cat-image.png\u0026#39;)); const {width, height} = await webelement.getrect();  "
},
{
	"uri": "/docs/cookbook/",
	"title": "Cookbook",
	"tags": [],
	"description": "",
	"content": " browse through our cookbook and get answers, best practices and tipps\u0026amp;tricks right away\u0026hellip;! "
},
{
	"uri": "/docs/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " the pinnacle of testing behavior and performance validation of basically every application. test like a real-world user!\n"
},
{
	"uri": "/docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
